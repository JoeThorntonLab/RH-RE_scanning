---
title: "Phenotype frequency distributions final"
author: "Jaeda Patton"
date: "2023-10-16"
output: github_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE, purl=TRUE}
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=5, fig.height=5, warning = FALSE, 
                      message = FALSE)
basedir <- file.path("..", "..")

# check for packages and install any that are missing
packages <- c("tidyr", "ggplot2", "Matrix", "stringr", "tibble", "purrr", "tune", 
              "MASS", "patchwork", "viridis", "lemon", "ggsignif", "dunn.test", 
              "doParallel", "ggseqlogo", "ggalluvial", "ggrepel",
              "gplots", "Biostrings", "igraph", "forcats", "magrittr", "scales", 
              "dplyr", "onls")
bioconductor_packages <- c()
installed_packages <- packages %in% rownames(installed.packages())
installed_bioc_packages <- bioconductor_packages %in% 
  rownames(installed.packages())

install.packages(packages[!installed_packages])
if(any(installed_bioc_packages == F)) {
  if(!require("BiocManager", quietly = T)) install.packages("BiocManager")
  BiocManager::install(bioconductor_packages[!installed_bioc_packages])
}

installed_packages <- packages %in% rownames(installed.packages())
installed_bioc_packages <- bioconductor_packages %in% 
  rownames(installed.packages())

# load packages
invisible(lapply(c(bioconductor_packages[installed_bioc_packages], 
                   packages[installed_packages]), 
                 library, character.only=TRUE))


# make output directories
results_dir <- file.path(basedir, "results", 
                         "phenotype_frequency_distributions_final")
if(!dir.exists(results_dir)) dir.create(results_dir)

# plot fontsize
fontsize <- 16
```


This notebook classifies variants as functional vs. nonfunctional based on their estimated mean fluorescence and analyzes the distribution of phenotypes in each ancestral sequence space (AncSR1 and AncSR2). The mean fluorescence data is generated by the `mutation_effects_model_fitting.Rmd` notebook, with fluorescence estimates coming from four sources:

1. "Binned" variants are those for which we have replicate measurements of fluorescence from the second-round (binned) sort-seq experiment (`data_cleaning.Rmd`).

2. "Debulk" variants are those whose fluorescence is inferred null due to being observed at high frequency in the first-round (debulk) sort-seq experiment and absent in the binned sort-seq experiment (`data_cleaning.Rmd`).

3. "Predicted" variants are those which not observed in either the binned or debulk datasets, whose fluorescence is inferred from the genetic effects model (`mutation_effects_model_fitting.Rmd`).

4. GARE variants, whose original fluorescence came from any of the three sources above. These original fluorescence values have been corrected to account for a general affinity-decreasing effect of the GARE background, which is different from that of the other 15 strains (`mutation_effects_model_fitting.Rmd`). (The CCRE strain has yet a different background which likely also has an effect on affinity, but we are unable to estimate the size of this effect. The unmodified fluorescence values are thus used for this strain.)

## Loading data and functions

```{r load, purl = T}
# load general functions
source(file.path(basedir, "scripts", "general_functions.R"))
source(file.path(basedir, "scripts", "onlsmod.R"))

# reading in complete fluorescence data
AncSR1_meanF_data <- read.csv(file.path(basedir, "results", 
                                        "mutation_effects_model",
                                        "AncSR1_complete_data_corrected.csv.gz"), 
                              stringsAsFactors = TRUE)
AncSR2_meanF_data <- read.csv(file.path(basedir, "results", 
                                        "mutation_effects_model",
                                        "AncSR2_complete_data_corrected.csv.gz"), 
                              stringsAsFactors = TRUE)
meanF_data <- bind_rows(AncSR1 = AncSR1_meanF_data, AncSR2 = AncSR2_meanF_data, 
                        .id = "bg") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  arrange(bg, AA_var, RE)
rm(AncSR1_meanF_data, AncSR2_meanF_data)
```


## How many functional variants are there in each ancestral background?

We define "functional" variants as those with fluorescence at least as high as that of the wild type complex for the respective background (*i.e.* EGKA:ERE for the AncSR1 background and GKSV:SRE for the AncSR2 background).

```{r fcutoff, purl = T}
# defining minimum fluorescence cutoffs for functional variants
AncSR1WT_ERE_data <- meanF_data %>% 
  filter(AA_var == "EGKA", bg == "AncSR1", RE == "ERE (GT)")
AncSR2WT_SRE_data <- meanF_data %>% 
  filter(AA_var == "GSKV", bg == "AncSR2", RE == "SRE (AA)")
```


To classify variants as functional or nonfunctional, we test whether their fluorescence is significantly lower than that of the reference variant. If it is, then variants are classified as nonfunctional; otherwise they are considered functional.

Since our fluorescence estimates come from different sources (observed vs. inferred), we use different tests to classify the variants whose fluorescence is estimated from the binned sort data, the debulk sort data, and the mutation effects models:

1. Debulk variants are automatically considered nonfunctional (except for GARE variants whose original fluorescence estimates were from the debulk sort; these are classified using the method for predicted variants described below). 

2. Binned variants are classified using a two sample t-test, with the null hypothesis that their fluorescence is greater than or equal to that of the reference variant. GARE variants whose fluorescence was originally measured in the binned sort experiment are also classified this way, but using the corrected mean fluorescence. The deviations from the mean observed in the original binned sort measurements are taken as the error around the corrected mean.

3. Predicted variants are classified using a nonparametric bootstrap test, with the same null hypothesis as above. This approach takes advantage of the fact that we can use the prediction error observed during cross-validation of the genetic effects models as an estimate of the error associated with each predicted variant's fluorescence. For each variant with predicted fluorescence $F_{\text{test}}$, we take the distribution of cross-validation residuals in the interval $F_{\text{test}} \pm 0.1$ as an estimate of the prediction error distribution for that variant. We then create bootstrap fluorescence samples from this distribution and compute the p-value as the fraction of the bootstrap sample with fluorescence greater than or equal to the reference variant. This is done separately for AncSR1 vs. AncSR2 variants, since the models were fit separately for each protein background and thus have different error distributions.

After computing p-values, we use a false-discovery rate of 0.25 for multiple testing correction. Since we are testing whether variants are significantly less fluorescent than the reference variant, this means that we expect 25% of variants called nonfunctional to actually be functional (*i.e.* not significantly less fluorescent than the reference variant). While this may seem like a high FDR rate, this helps us to control the rate at which variants are erroneously classified as functional, which is likely to be high for predicted variants. This is due to the low prediction accuracy of the genetic effects models in the dynamic range of fluorescence, especially for the AncSR1 dataset (see below).

```{r pfunctionalbinned, purl = TRUE}
# Compute p-value for calling variants functional that were observed in the 
# binned sort experiment.
#
# H0: Variant is at least as fluorescent as reference variant.
# HA: Variant is less fluorescent than reference variant.
# Use a t-test and FDR-adjusted p-value. Variants with padj < 0.25 are called 
# nonfunctional.

# First, adjust measurement error to be centered around predicted meanF for GA
# predicted variants
meanF_data <- meanF_data %>%
  mutate(orig_meanF = rowMeans(select(., meanF_REP1:meanF_REP4), na.rm = TRUE),
         meanF_REP1 = avg_meanF + (meanF_REP1 - orig_meanF),
         meanF_REP2 = avg_meanF + (meanF_REP2 - orig_meanF),
         meanF_REP3 = avg_meanF + (meanF_REP3 - orig_meanF),
         meanF_REP4 = avg_meanF + (meanF_REP4 - orig_meanF)) %>%
  select(-orig_meanF)

if(!file.exists(file.path(results_dir, "pbinned.rda"))) {
  # parallel processing
  cores <- 2
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  pbinned <- foreach(i = c("AncSR1", "AncSR2"), .combine = 'c') %dopar% {
    ref <- ifelse(i == "AncSR1", AncSR1WT_RE_data, AncSR2WT_SRE_data)
    apply(select(filter(meanF_data, bg == i), meanF_REP1:meanF_REP4), 
          1, function(x)
      t.test(as.numeric(x), 
             as.numeric(select(ref, meanF_REP1:meanF_REP4)),
             "less", na.action = "na.omit")$p.value)
  }
  stopCluster(cl)
  
  save(pbinned, file = file.path(results_dir, "pbinned.rda"))
} else load(file.path(results_dir, "pbinned.rda"))
```


```{r pfunctionalpredictedAncSR1, purl = TRUE, fig.height = 4}
# For variants with predicted fluorescence from reference-free model, test for
# fluorescence less than the reference with a nonparametric bootstrap test,
# where bootstrapped fluorescence samples are taken from the cross-validation
# error distribution for variants with fluorescence similar to that of the test
# variant. This method helps to account for the non-normal error distributions
# observed for high predicted fluorescence values.
#
# H0: Variant is at least as fluorescent as reference variant.
# HA: Variant is less fluorescent than reference variant.
# Adjust p-value using FDR correction. Variants with padj < 0.1 are called 
# nonfunctional.

# First test AncSR1 predicted variants

# first load the cross-validation fits from the model fitting
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR1.cv.pred.fine.rda"))
load(file.path(basedir, "results", "mutation_effects_model", "AncSR1_foldid.rda"))
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR1_model_data.rda"))
AncSR1.cv.pred <- lapply(AncSR1.cv.pred.fine, function(x) as.numeric(x[,10]))

AncSR1.cv.obs <- lapply(1:10, function(x) 
  AncSR1_model_data$avg_meanF[AncSR1_foldid == x])

rm(AncSR1.cv.pred.fine, AncSR1_foldid, AncSR1_model_data)

# concatenate fits across all 10 cross-validation folds
AncSR1.cv <- data.frame(pred = unlist(AncSR1.cv.pred, use.names = FALSE),
                        obs = unlist(AncSR1.cv.obs, use.names = FALSE))

# plot concatentated predicted vs. observed fluorescence
ggplot(AncSR1.cv, aes(x = pred, y = obs)) +
  geom_bin2d(bins = 50) +
  scale_fill_viridis(trans = "log10", name = "Variants",
                     labels = label_comma()) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Predicted fluorescence", y = "Observed fluorescence", 
       title = "AncSR1 cross-validation fits, concatenated") +
  geom_hline(yintercept = AncSR1WT_ERE_data$avg_meanF, color = "gray", 
             linetype = "dashed")  +
  geom_vline(xintercept = AncSR1WT_ERE_data$avg_meanF, color = "gray", 
             linetype = "dashed")  +
  theme_classic()

# compute residuals
AncSR1.cv$res <- AncSR1.cv$obs - AncSR1.cv$pred

# Bootstrap predicted fluorescence based on CV error distributions. For each
# predicted variant, sample from the distribution of CV residuals concatenated
# across all 10 CV folds, within a range of +/- 0.1 of the predicted
# fluorescence. Sample 250 bootstrap samples per replicate.

if(!file.exists(file.path(results_dir, "bspred.AncSR1.rda"))) {
  # parallel processing
  cores <- 24
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  bspred.AncSR1 <- foreach(i = 1:cores, .combine = 'cbind') %dopar% {
    data <- meanF_data %>% 
      filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR1")
    
    # split data into chunks
    size <- nrow(data)
    chunksize <- ceiling(size / cores)
    chunk <- data[((i - 1) * chunksize + 1):min(i * chunksize, size),]
    
    # create bootstrap reps
    sapply(chunk$avg_meanF, function(x) {
      # residual distribution centered around meanF of test variant
      res <- AncSR1.cv %>% filter(pred > x - 0.1 & pred < x + 0.1) %>% pull(res)
      # bootstrap
      sample(x + res, 250, replace = TRUE)
    })
  }
  stopCluster(cl)
  colnames(bspred.AncSR1) <- meanF_data %>% 
    filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR1") %>% 
    select(AA_var, RE) %>%
    unite(AA_var, RE, col = "var") %>% pull(var)
  save(bspred.AncSR1, file = file.path(results_dir, "bspred.AncSR1.rda"))
} else load(file.path(results_dir, "bspred.AncSR1.rda"))

# Compute p-value for functional variants as fraction of bootstrap replicates
# that are greater than or equal to that of the mean AncSR2:SRE1 WT variant.
if(!file.exists(file.path(results_dir, "ppredicted.AncSR1.rda"))) {
  ppredicted.AncSR1 <- apply(bspred.AncSR1, 2, function(x) 
    sum(x >= AncSR1WT_ERE_data$avg_meanF) / 250)
  save(ppredicted.AncSR1, file = file.path(results_dir, "ppredicted.AncSR1.rda"))
} else load(file.path(results_dir, "ppredicted.AncSR1.rda"))

rm(bspred.AncSR1)
```

```{r pfunctionalpredictedAncSR2, purl = TRUE, fig.height = 4}
# Repeat for AncSR2 predicted variants

# first load the cross-validation fits from the model fitting
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR2.cv.pred.fine.rda"))
load(file.path(basedir, "results", "mutation_effects_model", "AncSR2_foldid.rda"))
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR2_model_data.rda"))
AncSR2.cv.pred <- lapply(AncSR2.cv.pred.fine, function(x) as.numeric(x[,13]))

AncSR2.cv.obs <- lapply(1:10, function(x)
  AncSR2_model_data$avg_meanF[AncSR2_foldid == x])

rm(AncSR2.cv.pred.fine, AncSR2_foldid, AncSR2_model_data)

# concatenate fits across all 10 cross-validation folds
AncSR2.cv <- data.frame(pred = unlist(AncSR2.cv.pred, use.names = FALSE),
                        obs = unlist(AncSR2.cv.obs, use.names = FALSE))

# plot concatentated predicted vs. observed fluorescence
ggplot(AncSR2.cv, aes(x = pred, y = obs)) +
  geom_bin2d(bins = 50) +
  scale_fill_viridis(trans = "log10", name = "Variants",
                     labels = label_comma()) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Predicted fluorescence", y = "Observed fluorescence", 
       title = "AncSR2 cross-validation fits, concatenated") +
  geom_hline(yintercept = AncSR2WT_SRE_data$avg_meanF, color = "gray", 
             linetype = "dashed")  +
  geom_vline(xintercept = AncSR2WT_SRE_data$avg_meanF, color = "gray", 
             linetype = "dashed")  +
  theme_classic()

# compute residuals
AncSR2.cv$res <- AncSR2.cv$obs - AncSR2.cv$pred

# Bootstrap predicted fluorescence based on CV error distributions. For each
# predicted variant, sample from the distribution of CV residuals concatenated
# across all 10 CV folds, within a range of +/- 0.1 of the predicted
# fluorescence. Sample 250 bootstrap samples per replicate.

if(!file.exists(file.path(results_dir, "bspred.AncSR2.rda"))) {
  # parallel processing
  cores <- 24
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  bspred.AncSR2 <- foreach(i = 1:cores, .combine = 'cbind') %dopar% {
    data <- meanF_data %>% 
      filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR2")
    
    # split data into chunks
    size <- nrow(data)
    chunksize <- ceiling(size / cores)
    chunk <- data[((i - 1) * chunksize + 1):min(i * chunksize, size),]
    
    # create bootstrap reps
    sapply(chunk$avg_meanF, function(x) {
      # residual distribution centered around meanF of test variant
      res <- AncSR2.cv %>% filter(pred > x - 0.1 & pred < x + 0.1) %>% pull(res)
      # bootstrap
      sample(x + res, 250, replace = TRUE)
    })
  }
  stopCluster(cl)
  colnames(bspred.AncSR2) <- meanF_data %>% 
    filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
           bg == "AncSR2") %>% 
    select(AA_var, RE) %>%
    unite(AA_var, RE, col = "var") %>% pull(var)
  save(bspred.AncSR2, file = file.path(results_dir, "bspred.AncSR2.rda"))
} else load(file.path(results_dir, "bspred.AncSR2.rda"))

# Compute p-value for functional variants as fraction of bootstrap replicates
# that are greater than or equal to that of the mean AncSR2:SRE1 WT variant.
if(!file.exists(file.path(results_dir, "ppredicted.AncSR2.rda"))) {
  ppredicted.AncSR2 <- apply(bspred.AncSR2, 2, function(x) 
    sum(x >= AncSR2WT_SRE_data$avg_meanF) / 250)
  save(ppredicted.AncSR2, file = file.path(results_dir, "ppredicted.AncSR2.rda"))
} else load(file.path(results_dir, "ppredicted.AncSR2.rda"))

rm(bspred.AncSR2)
```

```{r classifyfunctional, purl = TRUE, fig.width = 8}
# classify variants as functional if padj >= 0.25 (not significantly less 
# fluorescent than AncSR2:SRE1 WT)
meanF_data <- rbind(meanF_data %>% filter(type == "binned") %>%
                      mutate(p = pbinned),
                    meanF_data %>%
                      filter(type == "predicted" | 
                               (type == "debulk" & RE == "SRE2 (GA)"), 
                             bg == "AncSR1") %>%
                      mutate(p = ppredicted.AncSR1),
                    meanF_data %>%
                      filter(type == "predicted" | 
                               (type == "debulk" & RE == "SRE2 (GA)"), 
                             bg == "AncSR2") %>%
                      mutate(p = ppredicted.AncSR2),
                    meanF_data %>%
                      filter(type == "debulk" & RE != "SRE2 (GA)") %>%
                      mutate(p = 0)) %>%
  mutate(padj = p.adjust(p, "fdr"), functional = padj >= 0.25, 
         RE = as.character(RE)) %>%
  mutate(RE = gsub("SRE2 \\(GA\\)", "GA", RE)) %>%
  mutate(RE = gsub("SRE1", "SRE", RE)) %>%
  mutate(RE = factor(RE, levels = levels(REs[[6]]))) %>%
  arrange(bg, AA_var, RE)

# export data
write.csv(meanF_data %>% filter(functional) %>% select(bg:meanF_REP4), 
          file = gzfile(file.path(results_dir, "meanF_data_fxnal.csv.gz"), 
                        compression = 9),
          row.names = FALSE)

# plot histogram of fluorescence colored by functional vs. not functional, as
# as well as source of fluorescence estimate (binned sort, debulk sort, or 
# predicted)
meanF_data %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = avg_meanF, fill = type, alpha = functional)) +
  geom_histogram(position = "stack") +
  scale_y_continuous(trans = log10plus1, name = "Count + 1") +
  scale_alpha_manual(values = c(0.6, 1)) +
  geom_vline(xintercept = AncSR1WT_ERE_data$avg_meanF, 
             color = "gray30", linetype = 2) +
  theme_classic() +
  labs(x = "Fluorescence")
meanF_data %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(x = avg_meanF, fill = type, alpha = functional)) +
  geom_histogram(position = "stack") +
  scale_y_continuous(trans = log10plus1, name = "Count + 1") +
  scale_alpha_manual(values = c(0.6, 1)) +
  geom_vline(xintercept = AncSR2WT_SRE_data$avg_meanF, 
             color = "gray30", linetype = 2) +
  theme_classic() +
  labs(x = "Fluorescence")

# plot fluorescence estimate source by RE for functional variants
meanF_data %>%
  filter(functional) %>%
  ggplot(aes(x = RE, fill = type)) +
  geom_bar() +
  facet_grid(rows = vars(bg), scales = "free_y") +
  theme_classic() +
  ylab("Number of functional variants") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```

The histograms above show the distribution of fluorescence for variants classified as functional vs. nonfunctional. The vertical dashed line shows the fluorescence of the reference variant. We can see that in the AncSR1 background, the fluorescence range for functional "predicted" variants extends much lower than the fluorescence of the reference variant. This is because the genetic effects model for the AncSR1 dataset exhibits a negative prediction bias as well as high error in the range of the reference variant (see cross-validation error plots, above). This means that AncSR1 variants with predicted fluorescence down to $\sim-4.0$ cannot be confidently inferred to have fluorescence significantly lower than that of the reference ($\sim-3.4$), and are classified as functional. Despite this, the majority of functional variants are binned variants (see table below), and the addition of the predicted variants does not have a qualitative impact on the distribution of functional variants per RE (except for GARE which has corrected up; see above bar plots). The fluorescence range for functional binned and predicted variants in the AncSR2 dataset is more similar because there is less bias and less prediction error in the AncSR2 model.

Let's look at the number of variants classified as functional on each ancestral background.

```{r countfxnalvars, purl = FALSE, fig.width = 4}
# print number of variants (protein:RE) classified as functional on each 
# background
meanF_data %>%
  group_by(bg, type) %>%
  summarize(count = sum(functional)) %>%
  pivot_wider(names_from = type, values_from = count) %>%
  mutate(all = binned + debulk + predicted, fraction.total = all / 2560000) %>%
  knitr::kable(caption = "Number of functional protein:RE variants")

# plot as bar plot
fxnalproteinREbgplot <- meanF_data %>%
  filter(functional) %>%
  ggplot(aes(x = bg, fill = bg)) +
  geom_bar() +
  scale_y_continuous(name = "Number of functional variants",
                     breaks = breaks_extended(6),
                     # sec.axis = sec_axis(trans = ~ . / (160000*16), 
                     #                     name = "Fraction of all possible"),
                     expand = expansion(mult = c(0.05, 0.1))
                     ) +
  # geom_text(stat = "count", 
  #           aes(label = paste0(..count.., " (", 
  #                              signif(..count.. / 2560000 * 100, 2), "%)")), 
  #           vjust = -1, size = 4) +
  geom_text(stat = "count",
            aes(label = paste0(signif(after_stat(count) / 2560000 * 100, 2), "%")),
            vjust = -1, size = 4) +
  scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(x = "", title = "Protein:RE variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))

# print number of protein variants classified as functional on each background
meanF_data %>%
  group_by(bg, AA_var) %>%
  summarize(functional = sum(functional) > 0) %>%
  group_by(bg) %>%
  summarize(count = sum(functional)) %>%
  mutate(fraction.total = count / 160000) %>%
  knitr::kable(caption = "Number of functional protein variants")

# plot as bar plot
fxnalproteinbgplot <- meanF_data %>%
  group_by(bg, AA_var) %>%
  summarize(functional = sum(functional) > 0) %>%
  filter(functional) %>%
  ggplot(aes(x = bg, fill = bg)) +
  geom_bar() +
  scale_y_continuous(name = "Number of functional variants",
                     breaks = breaks_extended(6),
                     # sec.axis = sec_axis(trans = ~ . / (160000), 
                     #                     name = "Fraction of all possible"),
                     expand = expansion(mult = c(0.05, 0.1))
                     ) +
  # geom_text(stat = "count", 
  #           aes(label = paste0(..count.., " (", 
  #                              signif(..count.. / 160000 * 100, 2), "%)")), 
  #           vjust = -1, size = 4) +
  geom_text(stat = "count",
            aes(label = paste0(signif(after_stat(count) / 160000 * 100, 2), "%")),
            vjust = -1, size = 4) +
  scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(x = "", title = "Protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))

fxnalproteinREbgplot + plot_spacer() + fxnalproteinbgplot + 
  plot_layout(widths = c(2, 0.5, 2))
```


## How many functional protein variants bind to each RE?

Let's now count the number of functional protein variants that bind to each RE variant.

```{r countfxnalRE, purl = FALSE}
nboundRE <- meanF_data %>%
  group_by(bg, RE) %>%
  summarize(n = sum(functional)) %>%
  ungroup() %>%
  complete(bg, RE, fill = list(n = 0))

nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  mutate(nincreaseAncSR2 = AncSR2 - AncSR1,
         foldincreaseAncSR2 = round(AncSR2 / AncSR1, 1)) %>%
  knitr::kable(caption = "Number of functional protein variants per RE")
```

Plot number of functional variants per RE.

```{r plotfxnalRE, purl = FALSE, fig.height = 6, fig.width = 7}
# bar plot (AncSR1 on top, AncSR2 on bottom)
fxnalREbarplotfacet <- nboundRE %>%
  ggplot(aes(x = RE, y = n, fill = bg)) +
  geom_col() +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))

fxnalREbarplotfacet

# bar plot (AncSR1/AncSR2 bars dodged)
fxnalREbarplotdodge <- nboundRE %>%
  ggplot(aes(x = RE, y = n, fill = bg)) +
  geom_col(position = "dodge") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))

fxnalREbarplotdodge

# AncSR1 bar plot, sorted in decreasing order
nboundRE %>%
  filter(bg == "AncSR1") %>%
  arrange(desc(n)) %>%
  # ggplot(aes(x = RE, y = n, fill = bg)) +
  ggplot(aes(x = factor(as.character(RE), levels = as.character(RE)),
             y = n, fill = bg)) +
  geom_col(position = "dodge", fill = "black") +
  scale_x_discrete(drop = FALSE) +
  # scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(title = "AncSR1 background", x = "RE", 
       y = "Number of protein\nvariants bound") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))

# AncSR2 bar plot, sorted in decreasing order
nboundRE %>%
  filter(bg == "AncSR2") %>%
  arrange(desc(n)) %>%
  # ggplot(aes(x = RE, y = n, fill = bg)) +
  ggplot(aes(x = factor(as.character(RE), levels = as.character(RE)),
             y = n, fill = bg)) +
  geom_col(position = "dodge", fill = "black") +
  scale_x_discrete(drop = FALSE) +
  # scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(title = "AncSR2 background", x = "RE", 
       y = "Number of protein\nvariants bound") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))
```


## Specificity vs. Promiscuity

Let's now identify how many protein variants bind specifically vs. promiscuously. Protein variants are defined as "specific" if they are functional on only one RE variant, and "promiscuous" if they bind to multiple RE variants.

```{r nspecific, purl = FALSE, fig.height = 5, fig.width = 6}
# Count the number of REs on which each protein variant is functional.
meanF_data_specificity <- meanF_data %>%
  pivot_wider(id_cols = bg:AA_var, names_from = RE, 
              values_from = c(avg_meanF, functional), 
              names_sep = "_") %>%
  mutate(nfxnal = rowSums(select(., 19:34)))

# Print the number of REs bound vs. number of protein variants
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(nfxnal = factor(nfxnal, levels = 1:16)) %>%
  group_by(bg, nfxnal) %>%
  dplyr::rename(nREs = nfxnal) %>%
  count(name = "nproteinvars") %>%
  group_by(bg) %>%
  mutate(fracfxnal = round(nproteinvars / sum(nproteinvars), 3)) %>%
  pivot_wider(names_from = bg, values_from = nproteinvars:fracfxnal, 
              values_fill = 0) %>%
  knitr::kable(caption = "Number of protein variants bound to n REs")

# Plot the number of REs on which each protein variant is functional
nREbarplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  ggplot(aes(x = nfxnal, fill = bg)) +
  geom_bar() +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_x_continuous(breaks = 1:16) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  xlab("Number of REs bound") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9))
nREbarplot
```


How many protein variants bind specifically to each RE?

```{r nREsbound, purl = FALSE}
# count the number of protein that bind specifically to each RE in each 
# background
nspecificRE <- meanF_data_specificity %>%
  filter(nfxnal == 1) %>%
  select(-c(3:18, nfxnal)) %>%
  pivot_longer(3:18, names_to = "RE", values_to = "fxnal", 
               names_prefix = "functional_") %>%
  mutate(RE = factor(RE, levels = levels(REs[[6]]))) %>%
  filter(fxnal) %>%
  group_by(bg, RE) %>%
  count(name = "nproteinvars") %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0))

kable(nspecificRE %>% 
        group_by(bg) %>%
        mutate(fracproteinvars = round(nproteinvars / sum(nproteinvars), 3)) %>%
        pivot_wider(names_from = bg, 
                    values_from = nproteinvars:fracproteinvars),
      caption = "Number of protein variants bound specifically per RE")
```

Create barplot.

```{r nspecificRE, purl = FALSE, fig.height = 6, fig.width = 7}
# plot number of protein variants bound specifically on each RE/background as a
# bar plot
nspecificbarplot <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  ggplot(aes(x = RE, y = nproteinvars, fill = bg)) +
  geom_col() +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants bound specifically") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))
nspecificbarplot
```

What are all of the various specificity and promiscuity phenotypes, and how many protein variants encode each of them?

```{r nspecificpromiscuous, purl = FALSE, fig.height = 6, fig.width = 7}
# plot number of protein variants encoding each encoded specificity and
# promiscuity phenotype as a bar plot.
nspecificpromiscuous <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  select(bg, `functional_ERE (GT)`:functional_TT) %>%
  count(across()) %>%
  arrange(bg, desc(n)) %>%
  mutate(label = apply(select(., `functional_ERE (GT)`:functional_TT), 1,
                       function(x) 
                         do.call(paste, 
                                 as.list(c(sub("functional_", "", colnames(.)[2:17])[x], sep = ", ")))),
         nREs = as.integer(rowSums(select(., `functional_ERE (GT)`:functional_TT))))

nspecificpromiscuous %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = factor(label, levels = label), y = n, fill = factor(nREs, levels = 1:5))) +
  geom_col() +
  scale_fill_viridis(discrete = TRUE, option = "C", drop = FALSE) +
  # scale_fill_manual(values = seq_gradient_pal(bg_color("AncSR1"), "yellow")(seq(0, 1, length.out = 5))) +
  labs(title = "AncSR1", x = "REs bound", 
       y = "Number of protein\nvariants bound", fill = "Number of\nREs") +
  theme_classic() +
  theme(text = element_text(size = fontsize)) +
  guides(x = guide_axis(angle = 45))

nspecificpromiscuous %>%
  filter(bg == "AncSR2") %>%
  slice_head(n = 20) %>%
  ggplot(aes(x = factor(label, levels = label), y = n, fill = factor(nREs, levels = 1:5))) +
  geom_col() +
  scale_fill_viridis(discrete = TRUE, option = "C", drop = FALSE) +
  # scale_fill_manual(values = seq_gradient_pal(bg_color("AncSR2"), "yellow")(seq(0, 1, length.out = 5))) +
  labs(title = "AncSR2", x = "REs bound", 
       y = "Number of protein\nvariants bound", fill = "Number of\nREs") +
  theme_classic() +
  theme(text = element_text(size = fontsize)) +
  guides(x = guide_axis(angle = 45))
```


Barplot with total bound and specifically bound variants per RE.

```{r nboundspecificRE, purl = FALSE, fig.height = 6, fig.width = 7}
# plot in decreasing order of number of specifically bound protein variants
nspecificboundbarplotAncSR1 <- meanF_data_specificity %>%
  ungroup() %>%
  filter(nfxnal > 0, bg == "AncSR1") %>%
  mutate(phenotype = ifelse(nfxnal == 1, "Specific", "Promiscuous")) %>%
  select(bg, AA_var, `functional_ERE (GT)`:functional_TT, phenotype) %>%
  pivot_longer(`functional_ERE (GT)`:functional_TT, names_to = "RE",
               values_to = "bound", names_prefix = "functional_") %>%
  filter(bound) %>%
  mutate(RE = factor(RE, levels = levels(REs[[6]]))) %>%
  count(RE, phenotype) %>%
  complete(RE, phenotype, fill = list(n = 0)) %>%
  pivot_wider(names_from = "phenotype", values_from = "n") %>%
  arrange(desc(Specific), desc(Promiscuous)) %>%
  pivot_longer(cols = 2:3, names_to = "phenotype", values_to = "n") %>%
  ggplot(aes(x = factor(as.character(RE), levels = unique(as.character(RE))),
             y = n, fill = phenotype)) +
  geom_col(position = "stack", color = "black") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = c("Specific" = "gray50", "Promiscuous" = "white")) +
  labs(title = "AncSR1", x = "RE", y = "Number of DBD variants", fill = "") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
         legend.position = "bottom") +
  guides(x = guide_axis(angle = 45))
nspecificboundbarplotAncSR1

nspecificboundbarplotAncSR2 <- meanF_data_specificity %>%
  ungroup() %>%
  filter(nfxnal > 0, bg == "AncSR2") %>%
  mutate(phenotype = ifelse(nfxnal == 1, "Specific", "Promiscuous")) %>%
  select(bg, AA_var, `functional_ERE (GT)`:functional_TT, phenotype) %>%
  pivot_longer(`functional_ERE (GT)`:functional_TT, names_to = "RE",
               values_to = "bound", names_prefix = "functional_") %>%
  filter(bound) %>%
  mutate(RE = factor(RE, levels = levels(REs[[6]]))) %>%
  count(RE, phenotype) %>%
  complete(RE, phenotype, fill = list(n = 0)) %>%
  pivot_wider(names_from = "phenotype", values_from = "n") %>%
  arrange(desc(Specific), desc(Promiscuous)) %>%
  pivot_longer(cols = 2:3, names_to = "phenotype", values_to = "n") %>%
  ggplot(aes(x = factor(as.character(RE), levels = unique(as.character(RE))),
             y = n, fill = phenotype)) +
  geom_col(position = "stack", color = "black") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = c("Specific" = "gray50", "Promiscuous" = "white")) +
  labs(title = "AncSR2", x = "RE", y = "Number of DBD variants", fill = "") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
         legend.position = "bottom") +
  guides(x = guide_axis(angle = 45))
nspecificboundbarplotAncSR2
```


Plots for Santi

```{r}
nboundbarplotAncSR1sorted <- nboundRE %>%
  filter(bg == "AncSR1") %>%
  arrange(desc(n)) %>%
  # ggplot(aes(x = RE, y = n, fill = phenotype)) +
  ggplot(aes(x = factor(as.character(RE), levels = unique(as.character(RE))),
             y = n, fill = RE)) +
  geom_col() +
  scale_fill_manual(values = c("ERE (GT)" = "#664797", "SRE (AA)" = "#00AC59",
                               rep("gray", 14))) +
  scale_x_discrete(drop = FALSE) +
  scale_y_continuous(sec.axis = sec_axis(trans = ~./sum(filter(nboundRE, bg == "AncSR1")$n), 
                                         name = "Relative fraction")) +
  labs(title = "AncSR1 background", x = "",
       y = "Number of\nprotein variants", fill = "Binding\nspecificity") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))
nboundbarplotAncSR1sorted + xlab("RE")
  

nboundbarplotAncSR2sorted <- nboundRE %>%
  arrange(rep(desc(filter(nboundRE, bg == "AncSR1")$n), 2)) %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(x = factor(as.character(RE), levels = unique(as.character(RE))),
             y = n, fill = RE)) +
  geom_col() +
  scale_fill_manual(values = c("ERE (GT)" = "#664797", "SRE (AA)" = "#00AC59",
                               rep("gray", 14))) +
  scale_x_discrete(drop = FALSE) +
  scale_y_continuous(sec.axis = sec_axis(trans = ~./sum(filter(nboundRE, bg == "AncSR2")$n), 
                                         name = "Relative fraction")) +
  labs(title = "AncSR2 background", x = "RE", 
       y = "Number of\nprotein variants", fill = "Binding\nspecificity") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))
nboundbarplotAncSR2sorted

(nboundbarplotAncSR1sorted + theme(axis.text.x = element_blank())) / nboundbarplotAncSR2sorted
```


Does the number of protein variants bound specifically per RE correlate with the total number of protein variants bound per RE?

```{r ntotalspecificREcor, purl = FALSE, fig.height = 5.5, fig.width = 8}
# plot number of protein variants bound specifically vs. number bound total per
# RE/bg
nboundspecificvtotalplotAncSR1 <- nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(nboundRE) %>%
  rename(ntotal = n) %>%
  filter(bg == "AncSR1") %>%
  {ggplot(., aes(x = ntotal, y = nspecific)) +
  geom_smooth(method = "lm", color = "black") +
  geom_point(color = bg_color("AncSR1")) +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  annotate(geom = "text", x = 0, y = 40, hjust = 0, vjust = 1, size = 5,
           label = paste(
             "adj.~R^2==", round(summary(lm(nspecific ~ ntotal, .))$adj.r.squared, 2)
           ), parse = TRUE) +
  labs(title = "AncSR1", 
       x = "Number of protein\nvariants bound total",
       y = "Number of protein variants\nbound specifically") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank())}
nboundspecificvtotalplotAncSR2 <- nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(nboundRE) %>%
  rename(ntotal = n) %>%
  filter(bg == "AncSR2") %>%
  {ggplot(., aes(x = ntotal, y = nspecific)) +
  geom_smooth(method = "lm", color = "black") +
  geom_point(color = bg_color("AncSR2")) +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  annotate(geom = "text", x = 0, y = 600, hjust = 0, vjust = 1, size = 5,
           label = paste(
             "adj.~R^2==", round(summary(lm(nspecific ~ ntotal, .))$adj.r.squared, 2)
           ), parse = TRUE) +
  labs(title = "AncSR2", 
       x = "Number of protein\nvariants bound total",
       y = "Number of protein variants\nbound specifically") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank())}
nboundspecificvtotalplotAncSR1 + nboundspecificvtotalplotAncSR2

# print Pearson's r^2 between total and specific variants bound per RE in each
# background
nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(nboundRE) %>%
  rename(ntotal = n) %>%
  group_by(bg) %>%
  summarize("r" = cor(nspecific, ntotal)) %>%
  mutate(r2 = r^2) %>%
  kable(caption = "r^2 n total vs. specific protein variants bound per RE")

# plot number protein variants bound and bound specifically per RE
nboundspecifictotalbarplot <- nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(meanF_data %>%
              filter(functional) %>%
              group_by(bg, RE) %>%
              summarize(ntotal = n())) %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nspecific = 0, ntotal = 0)) %>%
  mutate(npromiscuous = ntotal - nspecific) %>%
  pivot_longer(c(nspecific, npromiscuous), names_to = "specific", 
               names_prefix = "n", values_to = "n") %>%
  ggplot(aes(x = RE, y = n, fill = bg, alpha = specific)) +
  geom_col(position = "fill") +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  scale_alpha_manual(values = c("specific" = 1, "promiscuous" = 0.5)) +
  ylab("Number of protein variants bound") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "right") +
  guides(x = guide_axis(angle = 45))
nboundspecifictotalbarplot
```

For those protein variants that bind to multiple REs (promiscuous), which RE combinations do they bind to? Plot a heatmap of the number of protein variants that bind to each pair of REs. 

```{r promiscuousheatmaps, purl = FALSE, fig.height = 6, fig.width = 8}
npromiscuousREpairs <- map_dfr(combn(colnames(meanF_data_specificity)[19:34], 2,
                                     simplify = FALSE),
                               ~ meanF_data_specificity %>%
                                 filter(nfxnal >= 2) %>%
                                 select(c(bg, all_of(.x))) %>%
                                 mutate(n = rowSums(select(., -bg))) %>%
                                 group_by(bg) %>%
                                 summarize(pairs = paste(sub("functional_", "", .x), 
                                                         collapse = "_"),
                                           n = sum(n == 2))) %>%
  separate(pairs, c("RE1", "RE2"), sep = "_") %>%
  mutate(RE1 = factor(RE1, levels = levels(REs[[6]])),
         RE2 = factor(RE2, levels = levels(REs[[6]])))

promiscuousheatmapAncSR1 <- npromiscuousREpairs %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = RE1, y = RE2, fill = n)) +
  geom_tile() +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR1", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

# promiscuousheatmapAncSR1 <- npromiscuousREpairs %>%
#   filter(bg == "AncSR1") %>%
#   select(-bg) %>%
#   pivot_wider(names_from = "RE2", values_from = "n") %>%
#   column_to_rownames("RE1") %>%
#   apply(1:2, function(x) x / (meanF_data_specificity %>% 
#                                 filter(nfxnal >= 2, bg == "AncSR1") %>%
#                                 nrow())) %>%
#   heatmaply(dendrogram = "none")

promiscuousheatmapAncSR2 <- npromiscuousREpairs %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(x = RE1, y = RE2, fill = n)) +
  geom_tile() +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR2", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousheatmapAncSR1 + promiscuousheatmapAncSR2
```

Heatmaps v2

```{r promiscuousheatmaps2, purl = FALSE, fig.height = 5, fig.width = 7}
# fill scale: fraction of promiscuous variants
promiscuousheatmapbothbg <- npromiscuousREpairs %>%
  mutate(frac = ifelse(bg == "AncSR1", 
                       n / (meanF_data_specificity %>% 
                              filter(nfxnal >= 2, bg == "AncSR1") %>%
                              nrow()),
                       n / (meanF_data_specificity %>% 
                              filter(nfxnal >= 2, bg == "AncSR2") %>%
                              nrow()))) %>%
  ggplot(aes(fill = frac)) +
  geom_tile(data = . %>% filter(bg == "AncSR1"), aes(x = RE1, y = RE2)) +
  geom_tile(data = . %>% filter(bg == "AncSR2"), aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[6]])) +
  scale_y_discrete(limits = levels(REs[[6]])) +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "", y = "", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45))

# fill scale: fraction of specific variants
specificheatmapAncSR1 <- nspecificRE %>%
  ungroup() %>%
  filter(bg == "AncSR1") %>%
  select(-bg) %>%
  complete(RE, fill = list(nproteinvars = 0)) %>%
  mutate(frac = nproteinvars / (meanF_data_specificity %>%
                                  filter(nfxnal == 1, bg == "AncSR1") %>%
                                  nrow())) %>%
  ggplot(aes(x = RE, y = "Specific", fill = frac)) +
  geom_tile() +
  scale_x_discrete(limits = levels(REs[[6]]), position = "top") +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "AncSR1 background", y = "", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.title.x.top = element_text(size = fontsize),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())

specificheatmapAncSR2 <- nspecificRE %>%
  ungroup() %>%
  filter(bg == "AncSR2") %>%
  select(-bg) %>%
  complete(RE, fill = list(nproteinvars = 0)) %>%
  mutate(frac = nproteinvars / (meanF_data_specificity %>%
                                  filter(nfxnal == 1, bg == "AncSR2") %>%
                                  nrow())) %>%
  ggplot(aes(x = "Specific", y = RE, fill = frac)) +
  geom_tile() +
  scale_y_discrete(limits = levels(REs[[6]]), position = "right") +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "", y = "AncSR2 background", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.title.y.right = element_text(size = fontsize),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank()) +
  guides(x = guide_axis(angle = 45))

(specificheatmapAncSR1 + theme(legend.position = "none")) +
  plot_spacer() +
  (promiscuousheatmapbothbg + theme(legend.position = "none")) +
  (specificheatmapAncSR2 + theme(legend.position = "right")) +
  plot_layout(ncol = 2, byrow = TRUE, widths = c(16, 1), heights = c(1, 16))
```

Heatmaps v3

```{r promiscuousheatmaps3, purl = FALSE, fig.height = 6, fig.width = 8}
promiscuousspecificheatmapAncSR1 <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(fill = n)) +
  geom_tile(aes(x = RE1, y = RE2)) +
  geom_tile(aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[6]])) +
  scale_y_discrete(limits = levels(REs[[6]])) +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR1", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousspecificheatmapAncSR2 <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(fill = n)) +
  geom_tile(aes(x = RE1, y = RE2)) +
  geom_tile(aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[6]])) +
  scale_y_discrete(limits = levels(REs[[6]])) +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR2", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousspecificheatmapAncSR1 + promiscuousspecificheatmapAncSR2
```

Clustered heatmaps

```{r clusteredheatmap, purl = FALSE}
# AncSR1 (removed RE variants with nothing bound)
nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR1") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", 
            breaks = 0:max(.))

# AncSR2 (removed RE variants with nothing bound)
nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR2") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both",
            breaks = 0:max(.))
```

Clustered heatmaps no specific

```{r clusteredheatmapnospecific, purl = FALSE}
# AncSR1 (removed RE variants with nothing bound)
npromiscuousREpairs %>%
  filter(bg == "AncSR1") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  arrange(RE2, RE1) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n, values_fill = 0) %>%
  arrange(RE1) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", symm = TRUE,
            breaks = 0:max(.), margins = c(6, 6), density.info = "none", 
            key.title = "", key.xlab = "Number of protein variants",
            main = "AncSR1 background")

# AncSR2 (removed RE variants with nothing bound)
npromiscuousREpairs %>%
  filter(bg == "AncSR2") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  arrange(RE2, RE1) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n, values_fill = 0) %>%
  arrange(RE1) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", symm = TRUE,
            breaks = 0:max(.), margins = c(6, 6), density.info = "none", 
            key.title = "", key.xlab = "Number of protein variants",
            main = "AncSR2 background")
```



Are there RE sequence determinants of promiscuity?

```{r promiscuitydeterminantsRE, purl = FALSE, fig.height = 5, fig.width = 7}
# Can promiscuity be explained by modeling the probability of binding each RE
# variant as independent? First just look at the pairwise co-binding 
# probabilities (the probability that two REs are co-bound by the same protein
# variant)
REpairs <- as.data.frame(t(combn(levels(REs[[1]]), 2)))
colnames(REpairs) <- c("RE1", "RE2")
REpairs <- REpairs %>%
  left_join(nboundRE, by = c("RE1" = "RE")) %>%
  left_join(nboundRE, by = c("bg", "RE2" = "RE"), suffix = c("1", "2")) %>%
  left_join(meanF_data_specificity %>% 
              filter(nfxnal > 0) %>% 
              count(bg, name = "ntotal"), 
            by = "bg") %>%
  left_join(npromiscuousREpairs) %>%
  rename(n12 = n) %>%
  mutate(p1 = n1 / ntotal, p2 = n2 / ntotal, p12true = n12 / ntotal, 
         p12pred = p1 * p2) %>%
  filter(!(bg == "AncSR1" & RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE),
         !(bg == "AncSR1" & RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE),
         !(bg == "AncSR2" & RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE),
         !(bg == "AncSR2" & RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE))
coboundpairstruevpredplotAncSR1 <- REpairs %>%
  filter(bg == "AncSR1") %>%
  unite(RE1, RE2, col = "REs") %>%
  select(REs, p12true, p12pred) %>%
  {ggplot(., aes(x = p12pred, y = p12true)) +
  geom_point(color = bg_color("AncSR1")) +
  geom_smooth(method = "lm", color = "black") +
  # geom_abline(slope = 1, intercept = 0, color = "red") +
  # coord_obs_pred() +
  annotate(geom = "text", x = 0, y = 0.08, label = paste(
    "adj.~R^2==", round(summary(lm(p12true ~ p12pred, .))$adj.r.squared, 2)
  ), parse = TRUE, hjust = 0, size = 5, vjust = 1) +
  labs(y = "true co-binding frequency", 
       x = "predicted independent\nco-binding frequency",
       title = "AncSR1") +
  theme_classic() +
  theme(text = element_text(size = fontsize))}
coboundpairstruevpredplotAncSR2 <- REpairs %>%
  filter(bg == "AncSR2") %>%
  unite(RE1, RE2, col = "REs") %>%
  select(REs, p12true, p12pred) %>%
  {ggplot(., aes(x = p12pred, y = p12true)) +
  geom_point(color = bg_color("AncSR2")) +
  geom_smooth(method = "lm", color = "black") +
  # geom_abline(slope = 1, intercept = 0, color = "red") +
  # coord_obs_pred() +
  annotate(geom = "text", x = 0, y = 0.08, label = paste(
    "adj.~R^2==", round(summary(lm(p12true ~ p12pred, .))$adj.r.squared, 2)
  ), parse = TRUE, hjust = 0, size = 5, vjust = 1) +
  labs(y = "true co-binding frequency", 
       x = "predicted independent\nco-binding frequency",
       title = "AncSR2") +
  theme_classic() +
  theme(text = element_text(size = fontsize))}
coboundpairstruevpredplotAncSR1 + coboundpairstruevpredplotAncSR2

# How much more likely is an RE variant to be cobound with another RE variant 
# that has the same nucleotide at position 1 or 2 compared?
# Use a likelihood ratio test to test for effects of matching nucleotides at
# site 1 or 2 in the RE compared to a null model where cobinding frequencies are
# predicted from the independent binding expectation alone.
REpairsmatch <- REpairs %>%
  mutate(RE1 = gsub(".+\\(|\\)", "", RE1), RE2 = gsub(".+\\(|\\)", "", RE2)) %>%
  separate_wider_position(RE1, widths = c("RE1.1" = 1, "RE1.2" = 1)) %>%
  separate_wider_position(RE2, widths = c("RE2.1" = 1, "RE2.2" = 1)) %>%
  mutate(A1 = RE1.1 == "A" & RE2.1 == "A",
         C1 = RE1.1 == "C" & RE2.1 == "C",
         G1 = RE1.1 == "G" & RE2.1 == "G",
         T1 = RE1.1 == "T" & RE2.1 == "T",
         A2 = RE1.2 == "A" & RE2.2 == "A",
         C2 = RE1.2 == "C" & RE2.2 == "C",
         G2 = RE1.2 == "G" & RE2.2 == "G",
         T2 = RE1.2 == "T" & RE2.2 == "T")
  # mutate(match = map2_int(RE1, RE2, 
  #                         ~ str_split_fixed(c(.x, .y), "", 2) %>%
  #                           apply(2, function(x) x[1] == x[2]) %>%
  #                           {if(sum(.) == 1) which(.) else 0}))

REsiteeffect <- as.data.frame(matrix(nrow = 0, ncol = 4))
colnames(REsiteeffect) <- c("bg", "effect", "beta", "p")
for(b in c("AncSR1", "AncSR2")) {
  lmH0 <- lm(p12true ~ p12pred, REpairsmatch %>% filter(bg == b))
  print(b)
  print(summary(lmH0))
  for(position in 1:2) {
    for(nt in c("A", "C", "G", "T")) {
      datasub <- REpairsmatch %>% filter(bg == b) %>%
      select(p12true, p12pred, paste0(nt, position)) %>%
        rename(match = paste0(nt, position))
      lmH1 <- lm(p12true ~ p12pred + match, datasub)
      LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
      pval <- pchisq(LRS, df = 1, lower.tail = FALSE)
      
      REsiteeffect <- REsiteeffect %>% 
      rbind(data.frame(bg = b, effect = paste0(nt, position), 
                       beta = coef(lmH1)[3], p = pval), 
            make.row.names = FALSE)
    }
  }
}
print(REsiteeffect)

REeffect <- as.data.frame(matrix(nrow = 0, ncol = 5))
colnames(REeffect) <- c("bg", "effect", "beta", "p", "adjr2")
for(b in c("AncSR1", "AncSR2")) {
  lmH0 <- lm(p12true ~ p12pred, REpairs %>% filter(bg == b))
  print(b)
  print(summary(lmH0))
  for(RE in levels(REs[[1]])) {
    datasub <- REpairs %>% filter(bg == b) %>%
    select(p12true, p12pred, RE1, RE2) %>%
      mutate(match = RE1 == RE | RE2 == RE)
    lmH1 <- lm(p12true ~ p12pred + match, datasub)
    LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
    pval <- pchisq(LRS, df = 1, lower.tail = FALSE)
    
    REeffect <- REeffect %>% 
    rbind(data.frame(bg = b, effect = RE, 
                     beta = coef(lmH1)[3], p = pval, 
                     adjr2 = summary(lmH1)$adj.r.squared), 
          make.row.names = FALSE)
  }
}
REeffect <- REeffect %>% drop_na()
REeffect$padj <- p.adjust(REeffect$p, method = "fdr")
print(REeffect)

# AncSR2 fit with SRE1 and SRE2 variables
datasub <- REpairs %>% filter(bg == "AncSR2") %>% 
  mutate(SRE1 = RE1 == "SRE1 (AA)" | RE2 == "SRE1 (AA)", 
         SRE2 = RE1 == "SRE2 (GA)" | RE2 == "SRE2 (GA)")
# test against SRE1-only model
lmH0 <- lm(p12true ~ p12pred + SRE1, datasub)
lmH1 <- lm(p12true ~ p12pred + SRE1 + SRE2, datasub)
LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
pchisq(LRS, df = 1, lower.tail = FALSE)
# test against SRE2-only model
lmH0 <- lm(p12true ~ p12pred + SRE2, datasub)
LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
pchisq(LRS, df = 1, lower.tail = FALSE)
summary(lmH1)$adj.r.squared


# Plot fits with additional SRE1 and SRE2 RE explanatory variables
coboundpairstruevpredplotAncSR2SRE <- data.frame(pred = lmH1$fitted.values, 
                                                 obs = lmH1$model$p12true) %>%
  ggplot(aes(x = pred, y = obs)) +
  geom_point(color = bg_color()[2]) +
  geom_smooth(method = "lm", color = "red") +
  labs(y = "true co-binding frequency", 
       x = "predicted independent co-binding frequency",
       title = "AncSR2") +
  theme_classic()
(coboundpairstruevpredplotAncSR2 +
    labs(title = "AncSR2 independent frequency\npredictions")) + 
  (coboundpairstruevpredplotAncSR2SRE +
    labs(title = "AncSR2 independent frequency\npredictions + SRE1 + SRE2"))
```



## What is the mechanism behind more functional variants in the AncSR2 vs. AncSR1 background?

```{r meanF_data_fxnal, purl = TRUE}
# get protein:RE variants that are functional in both backgrounds
meanF_data_fxnal <- meanF_data %>%
  select(bg:avg_meanF, type, meanF_REP1:meanF_REP4, sd_meanF, functional, active) %>%
  pivot_wider(names_from = bg, values_from = avg_meanF:active) %>%
  filter(functional_AncSR1 | functional_AncSR2)
```

```{r permissivemech, purl = TRUE, fig.width = 7}
# How many variants that are functional in at least one ancestral background 
# have higher fluorescence in AncSR2? Use a nonparametric bootstrap test (like 
# the one used above for classifying functional variants) for variants with 
# model-predicted fluorescence in at least one background; for all others, use a 
# t-test.
if(!file.exists(file.path(results_dir, "phigherAncSR2.rda"))) {
  nbootstrap <- 1000
  phigherAncSR2 <- numeric(length = nrow(meanF_data_fxnal))
  for(i in 1:nrow(meanF_data_fxnal)) {
    # if fluorescence is from binned sort in both backgrounds, use a t-test
    if(meanF_data_fxnal$type_AncSR1[i] == "binned" && 
       meanF_data_fxnal$type_AncSR2[i] == "binned") {
      p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR1", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR2", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  alternative = "less",
                  na.action = "na.omit")$p.value
    } 
    # if fluorescence is model-predicted in either background, use bootstrap test
    else if(meanF_data_fxnal$type_AncSR1[i] == "predicted" ||
            meanF_data_fxnal$type_AncSR2[i] == "predicted" ||
            (meanF_data_fxnal$RE[i] == "GA" &&
             (meanF_data_fxnal$type_AncSR1[i] == "debulk" ||
              meanF_data_fxnal$type_AncSR2[i] == "debulk"))) {
      meanF_AncSR1 <- meanF_data_fxnal$avg_meanF_AncSR1[i]
      meanF_AncSR2 <- meanF_data_fxnal$avg_meanF_AncSR2[i]
      if(meanF_data_fxnal$type_AncSR1[i] %in% c("predicted", "debulk")) {
        # residual distribution centered around meanF of AncSR1 test variant
        res <- AncSR1.cv %>% 
          filter(pred > meanF_AncSR1 - 0.1 & pred < meanF_AncSR1 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR1 <- sample(meanF_AncSR1 + res, nbootstrap, replace = TRUE)
      }
      if(meanF_data_fxnal$type_AncSR2[i] %in% c("predicted", "debulk")) {
        # residual distribution centered around meanF of AncSR2 test variant
        res <- AncSR2.cv %>% 
          filter(pred > meanF_AncSR2 - 0.1 & pred < meanF_AncSR2 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR2 <- sample(meanF_AncSR2 + res, nbootstrap, replace = TRUE)
      }
      p <- sum(meanF_AncSR1 >= meanF_AncSR2) / nbootstrap
    } 
    # otherwise one variant must have fluorescence inferred from binned sort and
    # the other from debulk sort; use a one-sample t-test
    else {
      if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>%
                      select(grep("meanF_REP._AncSR2",
                                  colnames(meanF_data_fxnal),
                                  value = T)),
                    alternative = "greater",
                    mu = meanF_data_fxnal$avg_meanF_AncSR1[i],
                    na.action = "na.omit")$p.value
      } else {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                      select(grep("meanF_REP._AncSR1", 
                                  colnames(meanF_data_fxnal), 
                                  value = T)),
                    alternative = "less",
                    mu = meanF_data_fxnal$avg_meanF_AncSR2[i],
                    na.action = "na.omit")$p.value
      }
    }
    phigherAncSR2[i] <- p
  }
  
  save(phigherAncSR2, file = file.path(results_dir, "phigherAncSR2.rda"))
} else load(file.path(results_dir, "phigherAncSR2.rda"))

# FDR correction
padjhigherAncSR2 <- p.adjust(phigherAncSR2, "fdr")
print(paste("variants with higher fluorescence in AncSR2:", 
            sum(padjhigherAncSR2 < 0.05)))
print(paste("Fraction variants with higher fluorescence in AncSR2 out of those that are functional in either background:", 
            sum(padjhigherAncSR2 < 0.05) / nrow(meanF_data_fxnal)))

# FDR correction for only those variants that were measured in the binned sort
# in both backgrounds
padjhigherAncSR2binned <- p.adjust(
  phigherAncSR2[meanF_data_fxnal$type_AncSR1 == "binned" & meanF_data_fxnal$type_AncSR2 == "binned"],
  "fdr")
print(paste("variants with higher fluorescence in AncSR2 (binned only):", 
            sum(padjhigherAncSR2binned < 0.05)))
print(paste("Fraction variants with higher fluorescence in AncSR2 out of those that are functional in either background (binned only):", 
            sum(padjhigherAncSR2binned < 0.05) / length(padjhigherAncSR2binned)))

# plot fluorescence in each background colored by significance (only variants
# with binned sort measurements for both backgrounds)
bgfluorscatterplot <- meanF_data_fxnal %>%
  filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  mutate(padj = padjhigherAncSR2binned) %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  # geom_linerange(aes(xmin = avg_meanF_AncSR1 - sd_meanF_AncSR1 * 1.96,
  #                    xmax = avg_meanF_AncSR1 + sd_meanF_AncSR1 * 1.96)) +
  # geom_linerange(aes(ymin = avg_meanF_AncSR2 - sd_meanF_AncSR2 * 1.96,
  #                    ymax = avg_meanF_AncSR2 + sd_meanF_AncSR2 * 1.96)) +
  scale_color_discrete(labels = c(paste0("Not significant (", 
                                         round((1 - sum(padjhigherAncSR2binned < 0.05) / 
                                                   length(padjhigherAncSR2binned)) * 100, 1), "%)"),
                                  paste0("Significant (", 
                                         round(sum(padjhigherAncSR2binned < 0.05) / 
                                                  length(padjhigherAncSR2binned) * 100, 1), "%)")),
                       name = "Higher fluorescence in\nAncSR2 background") +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplot

# split scatter plot by RE
bgfluorscatterbyRE <- meanF_data_fxnal %>%
  filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  mutate(padj = padjhigherAncSR2binned) %>%
  group_by(RE) %>%
  mutate(frachigher = sum(padj < 0.05) / n(), 2) %>%
  {ggplot(., aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  # geom_linerange(aes(xmin = avg_meanF_AncSR1 - sd_meanF_AncSR1 * 1.96,
  #                    xmax = avg_meanF_AncSR1 + sd_meanF_AncSR1 * 1.96)) +
  # geom_linerange(aes(ymin = avg_meanF_AncSR2 - sd_meanF_AncSR2 * 1.96,
  #                    ymax = avg_meanF_AncSR2 + sd_meanF_AncSR2 * 1.96)) +
  facet_wrap(vars(RE)) +
  scale_color_manual(labels = c("Not higher in AncSR2", "Higher in AncSR2"), 
                     values = c("gray", "red"),
                     name = "") +
  geom_text(data = distinct(., RE, .keep_all = TRUE), 
            aes(label = sprintf("%0.2f", frachigher)), x = -2.8, y = -4.4, color = "black",
            vjust = 0, hjust = 1) +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "gray", linetype = "dashed") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()}
bgfluorscatterbyRE


# logo plots for ERE variants with higher vs. not higher fluorescence in AncSR2
EREAncSR2logo <- list("All ERE binders" = meanF_data_fxnal %>%
                              filter(RE == "ERE (GT)") %>%
                              pull(AA_var) %>% as.character(),
                            "Not higher on AncSR2" = meanF_data_fxnal %>%
                              filter(RE == "ERE (GT)", padjhigherAncSR2 >= 0.05) %>%
                              pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none")
EREAncSR2logo

EREAncSR2logo <- list("Higher on AncSR2" = meanF_data_fxnal %>%
                              filter(RE == "ERE (GT)", padjhigherAncSR2 < 0.05) %>%
                        filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
                              pull(AA_var) %>% as.character(),
                            "Not higher on AncSR2" = meanF_data_fxnal %>%
                              filter(RE == "ERE (GT)", padjhigherAncSR2 >= 0.05) %>%
                        filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
                              pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none")
EREAncSR2logo

list("AncSR1" = meanF_data %>%
       filter(RE == "ERE (GT)", bg == "AncSR1", functional) %>%
       pull(AA_var) %>% as.character(),
     "AncSR2" = meanF_data %>%
       filter(RE == "ERE (GT)", bg == "AncSR2", functional) %>%
       pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none")
```


Which variants have significantly *lower* expression in the AncSR2 background?

```{r, purl = FALSE, eval = FALSE}
# How many variants that are functional in at least one ancestral background 
# have lower fluorescence in AncSR2? Use a nonparametric bootstrap test (like 
# the one used above for classifying functional variants) for variants with 
# model-predicted fluorescence in at least one background; for all others, use a 
# t-test.
if(!file.exists(file.path(results_dir, "plowerAncSR2.rda"))) {
  nbootstrap <- 1000
  plowerAncSR2 <- numeric(length = nrow(meanF_data_fxnal))
  for(i in 1:nrow(meanF_data_fxnal)) {
    # if fluorescence is from binned sort in both backgrounds, use a two-sample 
    # t-test
    if(meanF_data_fxnal$type_AncSR1[i] == "binned" && 
       meanF_data_fxnal$type_AncSR2[i] == "binned") {
      p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR1", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR2", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  alternative = "greater",
                  na.action = "na.omit")$p.value
    } 
    # if fluorescence is model-predicted in either background, use bootstrap test
    else if(meanF_data_fxnal$type_AncSR1[i] == "predicted" ||
            meanF_data_fxnal$type_AncSR2[i] == "predicted" ||
            (meanF_data_fxnal$RE[i] == "GA" &&
             (meanF_data_fxnal$type_AncSR1[i] == "debulk" ||
              meanF_data_fxnal$type_AncSR2[i] == "debulk"))) {
      meanF_AncSR1 <- meanF_data_fxnal$avg_meanF_AncSR1[i]
      meanF_AncSR2 <- meanF_data_fxnal$avg_meanF_AncSR2[i]
      if(meanF_data_fxnal$type_AncSR1[i] %in% c("predicted", "debulk")) {
        # residual distribution centered around meanF of AncSR1 test variant
        res <- AncSR1.cv %>% 
          filter(pred > meanF_AncSR1 - 0.1 & pred < meanF_AncSR1 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR1 <- sample(meanF_AncSR1 + res, nbootstrap, replace = TRUE)
      }
      if(meanF_data_fxnal$type_AncSR2[i] %in% c("predicted", "debulk")) {
        # residual distribution centered around meanF of AncSR2 test variant
        res <- AncSR2.cv %>% 
          filter(pred > meanF_AncSR2 - 0.1 & pred < meanF_AncSR2 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR2 <- sample(meanF_AncSR2 + res, nbootstrap, replace = TRUE)
      }
      p <- sum(meanF_AncSR2 >= meanF_AncSR1) / nbootstrap
    } 
    # otherwise one variant must have fluorescence inferred from binned sort and
    # the other from debulk sort; use a one-sample t-test
    else {
      if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>%
                      select(grep("meanF_REP._AncSR2",
                                  colnames(meanF_data_fxnal),
                                  value = T)),
                    alternative = "less",
                    mu = meanF_data_fxnal$avg_meanF_AncSR1[i],
                    na.action = "na.omit")$p.value
      } else {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                      select(grep("meanF_REP._AncSR1", 
                                  colnames(meanF_data_fxnal), 
                                  value = T)),
                    alternative = "greater",
                    mu = meanF_data_fxnal$avg_meanF_AncSR2[i],
                    na.action = "na.omit")$p.value
      }
    }
    plowerAncSR2[i] <- p
  }
  
  save(plowerAncSR2, file = file.path(results_dir, "plowerAncSR2.rda"))
} else load(file.path(results_dir, "plowerAncSR2.rda"))

# FDR correction
padjlowerAncSR2 <- p.adjust(plowerAncSR2, method = "fdr")

# FDR correction for only those variants that were measured in the binned sort
# in both backgrounds
padjlowerAncSR2binned <- p.adjust(
  plowerAncSR2[meanF_data_fxnal$type_AncSR1 == "binned" & 
                  meanF_data_fxnal$type_AncSR2 == "binned"],
  "fdr")

bgfluorscatterbyRElowerAncSR2 <- meanF_data_fxnal %>%
  filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  mutate(padj = padjlowerAncSR2binned) %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  facet_wrap(vars(RE)) +
  scale_color_discrete(labels = c("Not significant", "Significant"), 
                       name = "Lower fluorescence in\nAncSR2 background,\nFDR = 0.2") +
  labs(title = "ERE variants",
       x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterbyRElowerAncSR2

meanF_data_fxnal %>%
  ungroup() %>%
  mutate(padj = padjlowerAncSR2 < 0.2) %>%
  count(RE, padj) %>%
  complete(RE, padj, fill = list(n = 0)) %>%
  group_by(RE) %>%
  mutate(frac = n / sum(n)) %>%
  filter(padj)

# just take the ones whose 95% CI is below the y=x line
lower_AncSR2 <- meanF_data_fxnal %>%
  filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  filter(avg_meanF_AncSR1 - sd_meanF_AncSR1 * 1.96 > 
           avg_meanF_AncSR2 + sd_meanF_AncSR2 * 1.96)

EREAncSR2logo <- list("Higher on AncSR2" = meanF_data_fxnal %>%
                        filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
                        mutate(padj = padjhigherAncSR2binned) %>%
                        filter(RE == "ERE (GT)", padj < 0.05) %>%
                        pull(AA_var) %>% as.character(),
                      "Not higher on AncSR2" = lower_AncSR2 %>%
                        filter(RE == "ERE (GT)") %>%
                        pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none")
EREAncSR2logo
```

Fitting models of nonspecific epistasis to by-background fluorescence data.

Nonspecific epistasis is modeled using the function

$$
F_2^* = \frac{F_1^* \alpha^n}{1 + F_1^* \alpha^n - F_1^*}
$$
where $F_1^*$ and $F_2^*$ are normalized fluorescence in the AncSR1 and AncSR2 backgrounds, respectively, $\alpha$ represents the effect of the background substitutions on affinity and/or stability of the DBD, and $n$ is a factor adjusting for the effect of affinity/stability on fluorescence. Fluorescence is normalized as

$$
F^* = \frac{F-F_L}{F_U-F_L}
$$

where $F_L$ and $F_U$ represent upper and lower measurement bounds, respectively. This model is modified from Park et al. 2022.

```{r bgnonspecificepistasis, purl = TRUE}
# get lower and upper bounds for each background inferred from RFA models
load(file.path(basedir, "results", "mutation_effects_model", "AncSR1_UL_fit.rda"))
load(file.path(basedir, "results", "mutation_effects_model", "AncSR2_UL_fit.rda"))
AncSR1_UL <- AncSR1_UL_fit$par[(length(AncSR1_UL_fit$par)-1):length(AncSR1_UL_fit$par)]
AncSR2_UL <- AncSR2_UL_fit$par[(length(AncSR2_UL_fit$par)-1):length(AncSR2_UL_fit$par)]
rm(AncSR1_UL_fit, AncSR2_UL_fit)

# fit a model with the same epistasis parameter (alpha) for all REs
bgepistasismodeldata <- meanF_data_fxnal %>%
  filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  mutate(padj = padjhigherAncSR2binned,
         meanF_AncSR1_norm = 
           (avg_meanF_AncSR1 - AncSR1_UL[1]) / (AncSR1_UL[2] - AncSR1_UL[1]),
         meanF_AncSR2_norm = 
           (avg_meanF_AncSR2 - AncSR2_UL[1]) / (AncSR2_UL[2] - AncSR2_UL[1]),
         ERE = RE == "ERE (GT)")

bgepistasismodel <- onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                           (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                         bgepistasismodeldata, start = list(alpha = 1, n = 1),
                         lower = c(1, 1), domain = c(0, 1))
print(bgepistasismodel)
plot(bgepistasismodel, segments = T, fitted.nls = F)
check_o(bgepistasismodel)

# get r^2 of model
cor(bgepistasismodel$y0, bgepistasismodel$resp)^2

# bootstrapping fits (1000 reps)
if(!file.exists(file.path(results_dir, "nonspecificepistasisbsallREs.rda"))) {
  # number of variants
  n <- bgepistasismodeldata %>% nrow()
  
  # parallel processing
  cores <- 20
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  
  nonspecificepistasisbsallREs <- foreach(i = 1:cores, .combine = 'rbind') %dopar% {
    # data frame to store bootstrapped parameter estimates
    bsdf <- data.frame(alpha = rep(0, 50), n = rep(0, 50))
    
    for(i in 1:50) {
      # sample non-ERE binding variants
      bs <- sample(n, n, replace = T)
      bs_data <- bgepistasismodeldata %>% slice(bs)
      # fit model
      bsdf[i,1:2] <- coef(
        onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                  (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                bs_data, start = list(alpha = 1, n = 1),
                lower = c(1, 1), domain = c(0, 1), verbose = F))
    }
    
    bsdf
  }
  stopCluster(cl)
  save(nonspecificepistasisbsallREs, 
       file = file.path(results_dir, "nonspecificepistasisbsallREs.rda"))
} else load(file.path(results_dir, "nonspecificepistasisbsallREs.rda"))

# get 95% confidence intervals
bgepistasisbsciallREs <- nonspecificepistasisbsallREs[sort(nonspecificepistasisbsallREs[,1])[c(25, 976)],]

# plot inferred model
bgfluorscatterplotfit <- bgepistasismodeldata %>%
  arrange(desc(padj)) %>%
  ggplot(aes(x = meanF_AncSR1_norm)) +
  geom_point(aes(y = meanF_AncSR2_norm, color = padj < 0.05), size = 2) +
  # 95% confidence intervals
  # geom_ribbon(data = data.frame(
  #   x = seq(0, 1, 0.01), 
  #   lower = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbsciallREs[1,1], bgepistasisbsciallREs[1,2]),
  #   upper = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbsciallREs[2,1], bgepistasisbsciallREs[2,2])),
  #   aes(x = x, ymin = lower, ymax = upper),
  #   fill = "black", alpha = 0.3) +
  scale_color_manual(values = c("FALSE" = "gray40", 
                                "TRUE" = "red"),
                     name = "Fluorescence\nhigher in AncSR2") +
  geom_function(fun = bgepistasisfn,
                args = list(alpha = coef(bgepistasismodel)[1],
                            n = coef(bgepistasismodel)[2]),
                color = "black", xlim = c(0, 1), linewidth = 1) +
  geom_function(fun = function(x) x, color = "gray", 
                linetype = "dashed", linewidth = 1, xlim = c(0,1)) +
  # 95% prediction intervals
  # geom_line(data = bgepistasisbspinonERE, aes(x = x, y = lower95PI),
  #           color = "black", linetype = "dashed", linewidth = 1) +
  # geom_line(data = bgepistasisbspinonERE, aes(x = x, y = upper95PI),
  #           color = "black", linetype = "dashed", linewidth = 1) +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  xlim(-0.1, 1.1) + ylim(-0.1, 1.1) +
  # geom_abline(slope = 1, intercept = 0, color = "gray", 
  #             linetype = "dashed", linewidth = 1, xlim = c(0,1)) +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplotfit

# fit a model for only non-ERE data
bgepistasismodelnonERE <- onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                                    (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                                  filter(bgepistasismodeldata, !ERE), start = list(alpha = 1, n = 1),
                                  lower = c(1, 1), domain = c(0, 1))
print(bgepistasismodelnonERE)
plot(bgepistasismodelnonERE, segments = F, fitted.nls = F)
check_o(bgepistasismodelnonERE)
cor(bgepistasismodelnonERE$y0, bgepistasismodelnonERE$resp)^2

# fit a model for only ERE data
bgepistasismodelERE <- onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                                    (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                                  filter(bgepistasismodeldata, ERE), start = list(alpha = 1, n = 1),
                                  lower = c(1, 1), domain = c(0, 1))
print(bgepistasismodelERE)
plot(bgepistasismodelERE, segments = F, fitted.nls = F)
check_o(bgepistasismodelERE)
cor(bgepistasismodelERE$y0, bgepistasismodelERE$resp)^2

# bootstrapping fits (1000 reps)
if(!file.exists(file.path(results_dir, "nonspecificepistasisbs.rda"))) {
  # number of ERE/non-ERE binding variants
  n_nonERE <- bgepistasismodeldata %>% filter(!ERE) %>% nrow()
  n_ERE <- bgepistasismodeldata %>% filter(ERE) %>% nrow()
  
  # parallel processing
  cores <- 20
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  
  nonspecificepistasisbs <- foreach(i = 1:cores, .combine = 'rbind') %dopar% {
    # data frame to store bootstrapped parameter estimates
    bsdf <- data.frame(nonEREalpha = rep(0, 50), nonEREn = rep(0, 50),
                       EREalpha = rep(0, 50), EREn = rep(0, 50))
    
    for(i in 1:50) {
      # sample non-ERE binding variants
      bs_nonERE <- sample(n_nonERE, n_nonERE, replace = T)
      bs_nonERE_data <- bgepistasismodeldata %>% filter(!ERE) %>% slice(bs_nonERE)
      # fit model
      bsdf[i,1:2] <- coef(
        onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                  (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                bs_nonERE_data, start = list(alpha = 1, n = 1),
                lower = c(1, 1), domain = c(0, 1), verbose = F))
      
      # sample ERE-binding variants
      bs_ERE <- sample(n_ERE, n_ERE, replace = T)
      bs_ERE_data <- bgepistasismodeldata %>% filter(ERE) %>% slice(bs_ERE)
      # fit model
      bsdf[i,3:4] <- coef(
        onlsmod(meanF_AncSR2_norm ~ meanF_AncSR1_norm * I((alpha)^n) /
                  (1 + meanF_AncSR1_norm * I((alpha)^n) - meanF_AncSR1_norm),
                bs_ERE_data, start = list(alpha = 1, n = 1),
                lower = c(1, 1), domain = c(0, 1), verbose = F))
    }
    
    bsdf
  }
  stopCluster(cl)
  save(nonspecificepistasisbs, file = file.path(results_dir, "nonspecificepistasisbs.rda"))
} else load(file.path(results_dir, "nonspecificepistasisbs.rda"))

# bootstrap prediction intervals
bgepistasisfn <- function(AncSR1_norm, alpha, n) {
  AncSR1_norm * alpha^n / (1 + AncSR1_norm * alpha^n - AncSR1_norm)
}

# get predicted AncSR2 fluorescence for bootstrapped models
bgepistasisbsprednonERE <- t(apply(nonspecificepistasisbs, 1, 
                                 function(x) bgepistasisfn(seq(0, 1, 0.01), x[1], x[2])))
bgepistasisbspredERE <- t(apply(nonspecificepistasisbs, 1, 
                                function(x) bgepistasisfn(seq(0, 1, 0.01), x[3], x[4])))

# get 95% confidence intervals
bgepistasisbscinonERE <- nonspecificepistasisbs[sort(nonspecificepistasisbs[,1])[c(25, 976)], 1:2]
bgepistasisbsciERE <- nonspecificepistasisbs[sort(nonspecificepistasisbs[,3])[c(25, 976)], 3:4]

# get 95% prediction intervals
bgepistasisbspinonERE <- apply(bgepistasisbsprednonERE, 2, function(x) sort(x)[c(25, 976)])
bgepistasisbspiERE <- apply(bgepistasisbspredERE, 2, function(x) sort(x)[c(25, 976)])

# reformat for plotting
bgepistasisbspinonERE <- data.frame(x = seq(0, 1, 0.01),
                                    lower95PI = bgepistasisbspinonERE[1,],
                                    upper95PI = bgepistasisbspinonERE[2,])
bgepistasisbspiERE <- data.frame(x = seq(0, 1, 0.01),
                                 lower95PI = bgepistasisbspiERE[1,],
                                 upper95PI = bgepistasisbspiERE[2,])


# which variants are significantly outside of the 95% prediction interval?
# look for variants for which the SD of fluorescence in both backgrounds is outside of the lower
# bounds of the prediction interval.

# get bootstrap models for the lower bound of the 95% prediction interval

# inverse bg epistasis function
bgepistasisfninv <- function(AncSR2_norm, alpha, n) {
  AncSR2_norm / (alpha^n + AncSR2_norm * (1 - alpha ^n))
}

# ERE binders
lowerPIERE <- which(apply(bgepistasisbspredERE, 1, function(x) 
  sum(x == bgepistasisbspiERE$lower95PI)) >= 100)
bgepistasismodeldataERE <- bgepistasismodeldata %>%
  filter(ERE) %>%
  mutate(lower95PIEREAncSR2 = bgepistasisfn(meanF_AncSR1_norm, 
                                            nonspecificepistasisbs[lowerPIERE, 3], 
                                            nonspecificepistasisbs[lowerPIERE, 4]),
         lower95PIEREAncSR1 = bgepistasisfninv(meanF_AncSR2_norm, 
                                            nonspecificepistasisbs[lowerPIERE, 3], 
                                            nonspecificepistasisbs[lowerPIERE, 4]),
         lower95PIEREAncSR2_unnorm = lower95PIEREAncSR2 * (AncSR2_UL[2] - AncSR2_UL[1]) + AncSR2_UL[1],
         lower95PIEREAncSR1_unnorm = lower95PIEREAncSR1 * (AncSR1_UL[2] - AncSR1_UL[1]) + AncSR1_UL[1],
         negativespecificepistasis = avg_meanF_AncSR1 - 1.96 * sd_meanF_AncSR1 > lower95PIEREAncSR1_unnorm & 
           avg_meanF_AncSR2 + 1.96 * sd_meanF_AncSR2 < lower95PIEREAncSR2_unnorm)

# logo plots of ERE-binding variants with significant specific negative epistasis
EREepistasislogo <- list("All ERE binders" = bgepistasismodeldataERE %>%
                        pull(AA_var) %>% as.character(),
                        "ERE binders with specific\nnegative interactions\nwith background substitutions" = 
                          bgepistasismodeldataERE %>%
                          filter(negativespecificepistasis) %>%
                          pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none",text = element_text(size = fontsize))
EREepistasislogo

# Other RE binders
lowerPInonERE <- which(apply(bgepistasisbsprednonERE, 1, function(x) 
  sum(x == bgepistasisbspinonERE$lower95PI)) >= 100)
bgepistasismodeldatanonERE <- bgepistasismodeldata %>%
  filter(!ERE) %>%
  mutate(lower95PInonEREAncSR2 = bgepistasisfn(meanF_AncSR1_norm, 
                                            nonspecificepistasisbs[lowerPInonERE, 1], 
                                            nonspecificepistasisbs[lowerPInonERE, 2]),
         lower95PInonEREAncSR1 = bgepistasisfninv(meanF_AncSR2_norm, 
                                            nonspecificepistasisbs[lowerPInonERE, 1], 
                                            nonspecificepistasisbs[lowerPInonERE, 2]),
         lower95PInonEREAncSR2_unnorm = lower95PInonEREAncSR2 * (AncSR2_UL[2] - AncSR2_UL[1]) + AncSR2_UL[1],
         lower95PInonEREAncSR1_unnorm = lower95PInonEREAncSR1 * (AncSR1_UL[2] - AncSR1_UL[1]) + AncSR1_UL[1],
         negativespecificepistasis = avg_meanF_AncSR1 - 1.96 * sd_meanF_AncSR1 > lower95PInonEREAncSR1_unnorm & 
           avg_meanF_AncSR2 + 1.96 * sd_meanF_AncSR2 < lower95PInonEREAncSR2_unnorm)

# logo plots of non-ERE-binding variants with significant specific negative epistasis
nonEREepistasislogo <- list("All variants" = bgepistasismodeldatanonERE %>%
                        pull(AA_var) %>% as.character(),
                        "Specific negative epistasis with background substitutions" = 
                          bgepistasismodeldatanonERE %>%
                          filter(negativespecificepistasis) %>%
                          pull(AA_var) %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  xlab("RH site") +
  theme(legend.position = "none")
nonEREepistasislogo

bgepistasismodeldatanonERE %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = negativespecificepistasis)) +
  geom_point(alpha = 0.5) +
  geom_linerange(aes(xmin = avg_meanF_AncSR1 - sd_meanF_AncSR1 * 1.96,
                     xmax = avg_meanF_AncSR1 + sd_meanF_AncSR1 * 1.96)) +
  geom_linerange(aes(ymin = avg_meanF_AncSR2 - sd_meanF_AncSR2 * 1.96,
                     ymax = avg_meanF_AncSR2 + sd_meanF_AncSR2 * 1.96)) +
  # geom_function(fun = bgepistasisfn,
  #               args = list(alpha = coef(bgepistasismodelnonERE)[1],
  #                           n = coef(bgepistasismodelnonERE)[2]),
  #               color = "black", xlim = c(0, 1), linewidth = 1) +
  # 95% prediction intervals
  geom_line(aes(y = lower95PInonEREAncSR2_unnorm),
            color = "black", linetype = "dashed", linewidth = 1) +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  # xlim(-0.1, 1.1) + ylim(-0.1, 1.1) +
  ylim(min(bgepistasismodeldatanonERE$avg_meanF_AncSR2), max(bgepistasismodeldatanonERE$avg_meanF_AncSR2)) +
  # geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()



# plot inferred models for ERE and non-ERE variants
bgfluorscatterplotfit <- bgepistasismodeldata %>%
  left_join(select(bgepistasismodeldataERE, AA_var, RE, negativespecificepistasis)) %>%
  replace_na(list(negativespecificepistasis = FALSE)) %>%
  arrange(ERE) %>%
  ggplot(aes(x = meanF_AncSR1_norm)) +
  geom_point(aes(y = meanF_AncSR2_norm, color = ERE,
                 shape = negativespecificepistasis), size = 2) +
  # 95% confidence intervals
  geom_ribbon(data = data.frame(
    x = seq(0, 1, 0.01), 
    lower = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbscinonERE[1,1], bgepistasisbscinonERE[1,2]),
    upper = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbscinonERE[2,1], bgepistasisbscinonERE[2,2])),
    aes(x = x, ymin = lower, ymax = upper),
    fill = "black", alpha = 0.3) +
  geom_ribbon(data = data.frame(
    x = seq(0, 1, 0.01), 
    lower = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbsciERE[1,1], bgepistasisbsciERE[1,2]),
    upper = bgepistasisfn(seq(0, 1, 0.01), bgepistasisbsciERE[2,1], bgepistasisbsciERE[2,2])),
    aes(x = x, ymin = lower, ymax = upper),
    fill = "purple2", alpha = 0.3) +
  
  scale_color_manual(labels = c("FALSE" = "No", "TRUE" = "Yes"), 
                     values = c("gray", "purple2"), name = "ERE") +
  scale_shape_discrete(labels = c("FALSE" = "No",
                                  "TRUE" = "Yes"),
                       name = "Specific negative\nepistasis") +
  geom_function(fun = bgepistasisfn,
                args = list(alpha = coef(bgepistasismodelnonERE)[1],
                            n = coef(bgepistasismodelnonERE)[2]),
                color = "black", xlim = c(0, 1), linewidth = 1) +
  # 95% prediction intervals
  # geom_line(data = bgepistasisbspinonERE, aes(x = x, y = lower95PI),
  #           color = "black", linetype = "dashed", linewidth = 1) +
  # geom_line(data = bgepistasisbspinonERE, aes(x = x, y = upper95PI),
  #           color = "black", linetype = "dashed", linewidth = 1) +
  geom_function(fun = bgepistasisfn,
                args = list(alpha = coef(bgepistasismodelERE)[1],
                            n = coef(bgepistasismodelnonERE)[2]),
                color = "purple2", xlim = c(0, 1), linewidth = 1) +
  # 95% prediction intervals
  # geom_line(data = bgepistasisbspiERE, aes(x = x, y = lower95PI),
  #           color = "purple2", linetype = "dashed", linewidth = 1) +
  # geom_line(data = bgepistasisbspiERE, aes(x = x, y = upper95PI),
  #           color = "purple2", linetype = "dashed", linewidth = 1) +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  xlim(-0.1, 1.1) + ylim(-0.1, 1.1) +
  # geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplotfit
```


What is the relationship between the number of variants bound per RE in the AncSR1 vs. AncSR2 background?

```{r nvarbg, purl = FALSE}
# scatter plot
fxnalREscatterplot <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  ggplot(aes(x = AncSR1, y = AncSR2)) +
  geom_smooth(method = "lm", color = "red") +
  geom_point() +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  labs(x = "Number of protein variants bound in AncSR1 background",
       y = "Number of protein variants bound in AncSR2 background") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
fxnalREscatterplot

# fitting linear model to number of protein variants bound per RE in each bg
nfxnalbglm <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  column_to_rownames("RE") %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbglm)
# outlier detection
par(mfrow = c(2,2))
plot(nfxnalbglm)  # ERE is likely an extreme outlier, and SRE a moderate outlier
cooksD <- cooks.distance(nfxnalbglm)
print(cooksD)
outliers <- cooksD[cooksD > (3 * mean(cooksD, na.rm = TRUE))]
print(outliers)
# refit model with outlier removed
nfxnalbglmnooutliers <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  filter(!RE %in% names(outliers)) %>%
  column_to_rownames("RE") %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbglmnooutliers)
# prediction interval
nfxnalbgprednooutliers <- predict(nfxnalbglmnooutliers,
                                  pivot_wider(nboundRE, names_from = bg, values_from = n),
                                  interval = "prediction")
nfxnalbgprednooutliers <- cbind(nfxnalbgprednooutliers, 
                                AncSR1 = nboundRE %>% filter(bg == "AncSR1") %>% pull(n))

# replot, show linear fit with outlier removed
fxnalREscatterplotnooutlier <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  ggplot(aes(x = AncSR1)) +
  # 95% prediction interval
  geom_ribbon(data = as.data.frame(nfxnalbgprednooutliers),
              aes(x = AncSR1, ymin = lwr, ymax = upr), color = "gray",
              alpha = 0.3) +
  geom_smooth(data = . %>% filter(!RE %in% names(outliers)),
              aes(y = AncSR2),
              method = "lm", color = "red", fullrange = TRUE, se = FALSE) +
  geom_point(aes(y = AncSR2)) +
  geom_text_repel(aes(y = AncSR2, label = RE), box.padding = 0.15) +
  # annotate(geom = "text", x = 0, y = 2500, label = "R^2==x", parse = TRUE) +
  annotate(geom = "text", x = 0, y = 2500, label = paste(
    "adj.~R ^ 2 ==", round(summary(nfxnalbglmnooutliers)$adj.r.squared, 2),
    "~(without~ERE)"),
    parse = TRUE, hjust = 0) +
  annotate(geom = "text", x = 0, y = 2350, label = paste(
    "adj.~R ^ 2 ==", round(summary(nfxnalbglm)$adj.r.squared, 2),
    "~(with~ERE)"),
    parse = TRUE, hjust = 0) +
  labs(x = "Number of protein variants bound\nin AncSR1 background",
       y = "Number of protein variants bound\nin AncSR2 background") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
fxnalREscatterplotnooutlier

nfxnalbgnoERESRE1lm <- nboundRE %>%
  filter(!RE %in% c("ERE (GT)", "SRE1 (AA)")) %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbgnoERESRE1lm)
```



## Other stuff

How do protein variants switch between specific and promiscuous categories between the AncSR1 and AncSR2 backgrounds? Do they switch specificity?

```{r bgphenotypeswitch, purl = FALSE, fig.height = 6, fig.width = 8}
# Of protein variants that are functional in either ancestral background, how do
# their phenotypes (specific, promiscuous, or nonfunctional) differ between the
# backgrounds?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in specificity/promsicuity phenotype")

specificpromiscuousswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if((.x == "specific" & .y == "promiscuous") |
                                 .x == "nonfunctional") "gained binding"
                             else if(.x == .y) "maintained binding"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c("specific", "promiscuous", 
                                            "nonfunctional")),
         AncSR2 = factor(AncSR2, levels = c("specific", "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("gained binding",
                                            "maintained binding",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
specificpromiscuousswitchplot

# Of protein variants that are specific in the AncSR1 background, do they change
# specificity or maintain the same specificity in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR1 == "specific") %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR1specificswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR1 %in% REs[[1]]) %>%
  replace_na(list(AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"
                             else if(.y == "promiscuous") "gained promiscuity"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = levels(REs[[1]])),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained promiscuity",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1specificswitchplot


# Of protein variants that are functional in the AncSR1 background, what is
# their phenotype in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR1 %in% c("specific", "promiscuous")) %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR1functionalswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR1 %in% c(levels(REs[[1]]), "promiscuous")) %>%
  replace_na(list(AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.y == "promiscuous") "gained/maintained promiscuity"
                             else if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c(levels(REs[[1]]), "promiscuous")),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained/maintained promiscuity",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1functionalswitchplot


# Of protein variants that are functional in the AncSR2 background, what is
# their phenotype in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR2 %in% c("specific", "promiscuous")) %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR2functionalswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR2 %in% c(levels(REs[[1]]), "promiscuous")) %>%
  replace_na(list(AncSR1 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.x == "nonfunctional") "gained binding"
                             else if(.y == "promiscuous") "gained/maintained promiscuity"
                             else if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c(levels(REs[[1]]), "promiscuous",
                                            "nonfunctional")),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained/maintained promiscuity",
                                            "gained binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR2functionalswitchplot


# of protein:RE variants that were functional in the AncSR1 background, did they
# stay functional or become nonfunctional in the AncSR2 background?
meanF_data_fxnal %>%
  filter(functional_AncSR1) %>%
  count(RE, functional_AncSR2) %>%
  mutate(RE = droplevels(RE)) %>%
  complete(RE, functional_AncSR2, fill = list(n = 0)) %>%
  group_by(RE) %>%
  mutate(ntotal = sum(n), frac = n / ntotal) %>%
  filter(!functional_AncSR2)

AncSR1functionalcomplexswitchplot <- meanF_data_fxnal %>%
  filter(functional_AncSR1) %>%
  count(functional_AncSR1, functional_AncSR2, RE) %>%
  mutate(AncSR1 = factor(ifelse(functional_AncSR1, "functional", "nonfunctional"),
                         levels = c("functional", "nonfunctional")),
         AncSR2 = factor(ifelse(functional_AncSR2, "functional", "nonfunctional"),
                         levels = c("functional", "nonfunctional"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = RE)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1functionalcomplexswitchplot
```


What are the amino acid sequence determinants of binding, specificity, and promiscuity?

```{r logoplots, purl = FALSE, fig.height = 6, fig.width = 7, eval = F}
allbindersbybglogoplot <- list(AncSR1 = meanF_data %>% 
                             filter(functional, bg == "AncSR1") %>% 
                             pull(AA_var) %>%
                             as.character() %>%
                             unique(),
                           AncSR2 = meanF_data %>%
                             filter(functional, bg == "AncSR2") %>%
                             pull(AA_var) %>%
                             as.character() %>%
                             unique()) %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize)) +
  labs(x = "RH position", title = "All binders")
allbindersbybglogoplot

allbindersbybgRElogoplot <- list(AncSR1 = meanF_data %>%
                                   filter(functional, bg == "AncSR1") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)},
                                 AncSR2 = meanF_data %>%
                                   filter(functional, bg == "AncSR2") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)}) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 4) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders")
allbindersbybgRElogoplot

# separate plots for each background
allbindersbybgRElogoplotAncSR1 <- meanF_data %>%
                                   filter(functional, bg == "AncSR1") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)} %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 2) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders AncSR1")
allbindersbybgRElogoplotAncSR1

allbindersbybgRElogoplotAncSR2 <- meanF_data %>%
                                   filter(functional, bg == "AncSR2") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)} %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 2) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders AncSR2")
allbindersbybgRElogoplotAncSR2


specificbinderslogoplot <- list(AncSR1 = meanF_data_specificity %>% 
                                  filter(nfxnal == 1, bg == "AncSR1") %>% 
                                  mutate(specificity = 
                                           apply(select(., `functional_ERE (GT)`:functional_TT), 
                                                 1, function(x) 
                                                   as.character(REs[[1]][which(x)]))) %>%
                                  {sapply(levels(REs[[1]]), function(x)
                                    filter(., specificity == x) %>% 
                                      pull(AA_var) %>% as.character(),
                                    USE.NAMES = TRUE)},
                                AncSR2 = meanF_data_specificity %>% 
                                  filter(nfxnal == 1, bg == "AncSR2") %>% 
                                  mutate(specificity = 
                                           apply(select(., `functional_ERE (GT)`:functional_TT), 
                                                 1, function(x) 
                                                   as.character(REs[[1]][which(x)]))) %>%
                                  {sapply(levels(REs[[1]]), function(x)
                                    filter(., specificity == x) %>% 
                                      pull(AA_var) %>% as.character(),
                                    USE.NAMES = TRUE)}) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 4) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "Specific binders")
specificbinderslogoplot

promiscuousbinderslogoplot <- list(AncSR1 = meanF_data_specificity %>% 
                                  filter(nfxnal > 1, bg == "AncSR1") %>% 
                                  pull(AA_var) %>% unique() %>% as.character(),
                                AncSR2 = meanF_data_specificity %>% 
                                  filter(nfxnal > 1, bg == "AncSR2") %>% 
                                  pull(AA_var) %>% unique() %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize)) +
  labs(x = "RH position", title = "Promiscuous binders")
promiscuousbinderslogoplot

promiscuouspairslogoplot <- list(AncSR1 = map2(c("ERE (GT)", "SRE1 (AA)", "SRE1 (AA)"),
                                               c("AT", "AT", "CA"),
                                               ~ meanF_data_specificity %>%
                                                 filter(bg == "AncSR1",
                                                        !!sym(paste0("functional_", .x)),
                                                        !!sym(paste0("functional_", .y))) %>%
                                                 pull(AA_var) %>% as.character()) %>%
                                   set_names(c("ERE (GT), AT", "SRE1 (AA), AT", "SRE1 (AA), CA")),
                                 AncSR2 = map2(c("SRE1 (AA)", "SRE1 (AA)", "SRE1 (AA)", "AT", "CA"),
                                               c("AT", "CA", "TA", "TT", "TA"),
                                               ~ meanF_data_specificity %>%
                                                 filter(bg == "AncSR2",
                                                        !!sym(paste0("functional_", .x)),
                                                        !!sym(paste0("functional_", .y))) %>%
                                                 pull(AA_var) %>% as.character()) %>%
                                   set_names(c("SRE1 (AA), AT", "SRE1 (AA), CA", "SRE1 (AA), TA", 
                                               "AT, TT", "CA, TA"))) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "Promiscuous binders")
promiscuouspairslogoplot
```






## What is the genetic basis of specificity vs. promiscuity?

```{r, purl = FALSE, eval = F}
# logo plots for all functional variants in the AncSR2 background
a <- ggseqlogo(meanF_data_functional %>% 
                 filter(bg == "AncSR2") %>%
                 pull(AA_var) %>% unique() %>% as.character(),
                 method = "bits") +
  theme(text=element_text(size=fontsize),
        plot.title = element_text(size = fontsize),
        legend.position = "none") +
  labs(x="AA position", title="All AncSR2 protein variants")
a

# logo plots for variants that bind specifically to one RE in the AncSR2 background
AncSR2_specific_vars <- lapply(REs[[1]], function(x) multiple_REs_variants %>%
                                 filter(bg == "AncSR2", nREs == 1, RE == x) %>% 
                                 pull(AA_var) %>%
                                 as.character())
names(AncSR2_specific_vars) <- REs[[1]]
AncSR2_specific_vars <- AncSR2_specific_vars[sapply(AncSR2_specific_vars, length) >= 50]
b <- ggseqlogo(AncSR2_specific_vars, 
          method="bits", ncol = length(meanF_data_functional)) +
  theme(text=element_text(size=fontsize),
        strip.text.x = element_text(size = fontsize),
        legend.position = "none") +
  labs(x="AA position")
b


# logo plots for variants that bind promiscuously to more than one RE in the AncSR2 background
c <- ggseqlogo(meanF_data_functional %>% 
                 filter(specific == "promiscuous", bg == "AncSR2") %>%
                 pull(AA_var) %>% unique() %>% as.character(), 
          method="bits") +
  theme(text=element_text(size=fontsize),
        legend.position = "none") +
  labs(x="AA position", title="Promiscuous AncSR2 protein variants")
c
```


## do variants switch between functional/nonfunctional/promiscuous/specific between AncSR1 and AnSR2?

```{r, purl = FALSE, eval = F}
alluvial_data <- multiple_REs_variants %>%
  mutate(specificity = factor(ifelse(nREs > 1, "promiscuous", RE), 
                           levels = c(levels(REs[[1]]), 
                                      "same specificity", "switched specificity", 
                                      "promiscuous", "nonfunctional"))) %>%
  select(AA_var, bg, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  filter(AncSR1 != "nonfunctional")
for(i in 1:nrow(alluvial_data)) {
  spec1 <- as.character(alluvial_data[i,2] %>% pull(1))
  spec2 <- as.character(alluvial_data[i,3] %>% pull(1))
  if(spec2 %in% as.character(REs[[1]])) {
    if(spec1 %in% as.character(REs[[1]])) {
      if(spec1 == spec2) alluvial_data[i,3] <- "same specificity"
      else alluvial_data[i,3] <- "switched specificity"
    } else {
      alluvial_data[i,3] <- "switched specificity"
    }
  }
}

alluvial_data <- alluvial_data %>%
  mutate(AncSR1 = factor(ifelse(AncSR1 %in% REs[[1]], "specific", "promiscuous"),
                         levels = c("promiscuous", "specific")),
         AncSR2 = factor(AncSR2, levels = c("promiscuous", "same specificity", 
                                            "switched specificity", "nonfunctional")))


a <- alluvial_data %>%
  filter(AncSR2 != "nonfunctional") %>%
  count(AncSR1, AncSR2) %>%
  ggplot(aes(axis1 = AncSR1, 
             axis2 = AncSR2, 
             y = n)) +
  geom_alluvium(aes(fill = AncSR2), width = 3/5) +
  geom_stratum(width = 3/5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 4) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  # scale_fill_manual(values = viridis(4)) +
  labs(title = "Protein variants functional\nin both backgrounds", 
       x = "", y = "Number of protein variants",
       fill = "AncSR2 phenotype") +
  theme_classic() +
  guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_text(size = fontsize))
a


# mean fluorescence for things that became promiscuous, 
# retained specificity, or retained promiscuity
b <- alluvial_data %>%
  filter(AncSR2 %in% c("promiscuous", "same specificity")) %>%
  unite(col = "phechange", AncSR1, AncSR2, sep = " to ") %>%
  mutate(phechange = factor(ifelse(phechange == "specific to same specificity",
                            "retained specificity", 
                            ifelse(phechange == "promiscuous to promiscuous",
                                   "retained promiscuity",
                                   phechange)),
                            levels = c("retained specificity",
                                       "specific to promiscuous",
                                   "retained promiscuity" ))) %>%
  inner_join(meanF_data_functional) %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = phechange, y = avg_meanF, fill = bg)) +
  geom_boxplot() +
  scale_fill_manual(values = bg_color("AncSR1")) +
  labs(x = "AncSR1 to AncSR2\nphenotype change", y = "Fluorescence", 
       fill = "", title = "Protein:RE variant combos\nfunctional in AncSR1 background") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        axis.line.x = element_line(color = "black",),
        legend.position = "none",
        plot.caption = element_text(hjust = 0)) +
  guides(x = guide_axis(angle = 45)) +
  geom_signif(comparisons = list(c("retained specificity", "specific to promiscuous"),
                                 c("specific to promiscuous", "retained promiscuity")), 
              test = "wilcox.test",
              test.args = list(alternative = "less"),
              map_signif_level = function(p) sprintf("p = %.2g", p))

c <- fluorescence_both_backgrounds %>%
  pivot_longer(3:4, names_to = "background") %>%
  ggplot(aes(x = background, y = value, fill = background)) +
  geom_boxplot() +
  scale_fill_manual(values = c(bg_color()), drop = FALSE) +
  labs(title = "Protein:RE variant combos\nfunctional in both backgrounds", 
       x = "Ancestral background", y = "", fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        axis.line.x = element_line(color = "black",),
        legend.position = "right",
        plot.caption = element_text(hjust = 0)) +
  guides(x = guide_axis(angle = 45)) +
  geom_signif(comparisons = list(c("AncSR1", "AncSR2")), 
              test = "wilcox.test",
              test.args = list(alternative = "less"),
              map_signif_level = function(p) sprintf("p = %.2g", p))

b + c + plot_layout(widths = c(3, 3))
```


# Network analysis

Let's create the genotype networks, where each node is a protein variant and their associated traits are the REs that they bind to.

```{r, purl = FALSE, eval = F}
# create data frame of which protein variants bind to which REs
# REs_bound <- multiple_REs_variants %>%
#   separate_longer_delim(cols = RE, delim = ", ") %>%
#   mutate(present = 1) %>%
#   pivot_wider(names_from = RE, values_from = present)
  

## AncSR1
AncSR1_comb <- combn(meanF_data_specificity %>% 
                       filter(bg == "AncSR1", nfxnal > 0) %>% 
                       pull(AA_var) %>% 
                       as.character(), 2)
AncSR1_edges <- t(AncSR1_comb)
AncSR1_connected <- apply(AncSR1_edges, 1, connected)
AncSR1_connected <- AncSR1_edges[AncSR1_connected,]
  

# create undirected graph where edges represent single step mutations between
# RH genotypes permissible by the genetic code; node attributes are boolean
# variables indicating binding to each RE, and one integer variable for number
# of REs bound
AncSR1_graph <- graph_from_data_frame(AncSR1_connected, directed=FALSE, 
                                      vertices = meanF_data_specificity %>% 
                                        filter(bg == "AncSR1", nfxnal > 0) %>% 
                                        select(AA_var, `functional_ERE (GT)`:nfxnal) %>%
                                        mutate(AA_var = as.character(AA_var)))
write_graph(AncSR1_graph, 
            file.path(results_dir, "AncSR1_RH_network.graphml"),
            format="graphml")

## AncSR2
AncSR2_comb <- combn(meanF_data_specificity %>% 
                       filter(bg == "AncSR2", nfxnal > 0) %>% 
                       pull(AA_var) %>% 
                       as.character(), 2)
AncSR2_edges <- t(AncSR2_comb)
AncSR2_connected <- apply(AncSR2_edges, 1, connected)
AncSR2_connected <- AncSR2_edges[AncSR2_connected,]
  

# create undirected graph where edges represent single step mutations between
# RH genotypes permissible by the genetic code; node attributes are boolean
# variables indicating binding to each RE, and one integer variable for number
# of REs bound
AncSR2_graph <- graph_from_data_frame(AncSR2_connected, directed=FALSE, 
                                      vertices = meanF_data_specificity %>% 
                                        filter(bg == "AncSR2", nfxnal > 0) %>% 
                                        select(AA_var, `functional_ERE (GT)`:nfxnal) %>%
                                        mutate(AA_var = as.character(AA_var)))
write_graph(AncSR2_graph, 
            file.path(results_dir, "AncSR2_RH_network.graphml"),
            format="graphml")
```


RH-RE networks

```{r, purl = FALSE, eval = F}
# AncSR1
AncSR1_RHRE_comb <- combn(meanF_data_specificity %>% 
                            filter(bg == "AncSR1", nfxnal > 0) %>% 
                            select(bg, AA_var, 
                                   `functional_ERE (GT)`:functional_TT) %>%
                            pivot_longer(`functional_ERE (GT)`:functional_TT, 
                                         names_to = "RE", 
                                         names_prefix = "functional_", 
                                         values_to = "functional") %>%
                            filter(functional) %>%
                            mutate(RE = sub(".+ \\(", "", RE)) %>%
                            mutate(RE = sub("\\)", "", RE)) %>%
                            unite(AA_var, RE, col = "var", sep = "") %>%
                            pull(var), 2)
AncSR1_RHRE_edges <- t(AncSR1_RHRE_comb)
AncSR1_RHRE_connected <- apply(AncSR1_RHRE_edges, 1, connected_RH_RE)
AncSR1_RHRE_connected <- AncSR1_RHRE_edges[AncSR1_RHRE_connected,]
AncSR1_RHRE_vertices <- unique(as.character(AncSR1_RHRE_comb))
AncSR1_RHRE_vertices <- data.frame(var = AncSR1_RHRE_vertices,
                                   RE = sub("....", "", AncSR1_RHRE_vertices))

AncSR1_RHRE_graph <- graph_from_data_frame(AncSR1_RHRE_connected, directed=FALSE, 
                                           vertices = AncSR1_RHRE_vertices)
write_graph(AncSR1_RHRE_graph, 
            file.path(results_dir, "AncSR1_RHRE_network.graphml"),
            format="graphml")

# RH network with only connections permitted by RH-RE coevolution
AncSR1_RH_RHRE_connected <- AncSR1_RHRE_connected %>%
  as.data.frame() %>% mutate(weight = as.numeric(str_sub(V1, 1, 4) != str_sub(V2, 1, 4)))
AncSR1_RH_RHRE_graph <- graph_from_data_frame(AncSR1_RH_RHRE_connected, directed=FALSE, 
                                              vertices = AncSR1_RHRE_vertices)
```

```{r, purl = FALSE, eval = F}
# AncSR2
AncSR2_RHRE_comb <- combn(meanF_data_specificity %>% 
                            filter(bg == "AncSR2", nfxnal > 0) %>% 
                            select(bg, AA_var, 
                                   `functional_ERE (GT)`:functional_TT) %>%
                            pivot_longer(`functional_ERE (GT)`:functional_TT, 
                                         names_to = "RE", 
                                         names_prefix = "functional_", 
                                         values_to = "functional") %>%
                            filter(functional) %>%
                            mutate(RE = sub(".+ \\(", "", RE)) %>%
                            mutate(RE = sub("\\)", "", RE)) %>%
                            unite(AA_var, RE, col = "var", sep = "") %>%
                            pull(var), 2)
AncSR2_RHRE_edges <- t(AncSR2_RHRE_comb)
if(!file.exists(file.path(results_dir, "AncSR2_RHRE_connected.rda"))) {
  AncSR2_RHRE_connected <- apply(AncSR2_RHRE_edges, 1, connected_RH_RE)
  save(AncSR2_RHRE_connected, file = file.path(results_dir, "AncSR2_RHRE_connected.rda"))
} else load(file.path(results_dir, "AncSR2_RHRE_connected.rda"))
AncSR2_RHRE_connected <- AncSR2_RHRE_edges[AncSR2_RHRE_connected,]
AncSR2_RHRE_vertices <- unique(as.character(AncSR2_RHRE_comb))
AncSR2_RHRE_vertices <- data.frame(var = AncSR2_RHRE_vertices,
                                   RE = sub("....", "", AncSR2_RHRE_vertices))

AncSR2_RHRE_graph <- graph_from_data_frame(AncSR2_RHRE_connected, directed=FALSE, 
                                           vertices = AncSR2_RHRE_vertices)
write_graph(AncSR2_RHRE_graph, 
            file.path(results_dir, "AncSR2_RHRE_network.graphml"),
            format="graphml")

# RH network with only connections permitted by RH-RE coevolution
AncSR2_RH_RHRE_connected <- AncSR2_RHRE_connected %>%
  as.data.frame() %>% mutate(weight = as.numeric(str_sub(V1, 1, 4) != str_sub(V2, 1, 4)))
AncSR2_RH_RHRE_graph <- graph_from_data_frame(AncSR2_RH_RHRE_connected, directed=FALSE, 
                                              vertices = AncSR2_RHRE_vertices)
```


### Clustering coefficient

```{r clustering}
# local clustering coefficient distribution
hist(transitivity(AncSR1_graph, type = "local"), main = "AncSR1", ylim = c(0, 60))
hist(transitivity(AncSR1_RHRE_graph, type = "local"), col = rgb(1,0,0,0.5), add = T)
hist(transitivity(AncSR2_graph, type = "local"), main = "AncSR2", ylim = c(0, 3000))
hist(transitivity(AncSR2_RHRE_graph, type = "local"), col = rgb(1,0,0,0.5), add = T)

# global clustering coefficient
transitivity(AncSR1_graph)
transitivity(AncSR1_RHRE_graph)
transitivity(AncSR2_graph)
transitivity(AncSR2_RHRE_graph)

# distances
AncSR1_distances <- distances(AncSR1_graph) %>%
  as.data.frame() %>%
  filter(AACQ != Inf) %>%
  select(which(colnames(.) %in% rownames(.)))
AncSR1_RHRE_distances <- distances(AncSR1_RHRE_graph) %>%
  as.data.frame() %>%
  filter(AARMAA != Inf) %>%
  select(which(colnames(.) %in% rownames(.)))
AncSR1_RH_RHRE_distances <- distances(AncSR1_RH_RHRE_graph) %>%  # only RH mutations and RH nodes counted
  as.data.frame() %>%
  filter(AARMAA != Inf) %>%
  distinct() %>%
  select(which(colnames(.) %in% rownames(.)))
hist(AncSR1_distances[upper.tri(AncSR1_distances)], xlim = c(1, 14))
hist(AncSR1_RH_RHRE_distances[upper.tri(AncSR1_RH_RHRE_distances)], col = rgb(1,0,0,0.5), add = T)

AncSR2_distances <- distances(AncSR2_graph) %>%
  as.data.frame() %>%
  filter(AAAI != Inf) %>%
  select(which(colnames(.) %in% rownames(.)))
AncSR2_RHRE_distances <- distances(AncSR2_RHRE_graph) %>%
  as.data.frame() %>%
  filter(AAAIAA != Inf) %>%
  select(which(colnames(.) %in% rownames(.)))
AncSR2_RH_RHRE_distances <- distances(AncSR2_RH_RHRE_graph) %>%  # only RH mutations and RH nodes counted
  as.data.frame() %>%
  filter(AAAIAA != Inf) %>%
  distinct() %>%
  select(which(colnames(.) %in% rownames(.)))
hist(AncSR2_distances[upper.tri(AncSR2_distances)], xlim = c(1, 14))
hist(AncSR2_RH_RHRE_distances[upper.tri(AncSR2_RH_RHRE_distances)], col = rgb(1,0,0,0.5), add = T)

t.test(as.numeric(AncSR1_distances[upper.tri(AncSR1_distances)]), 
       as.numeric(AncSR1_RH_RHRE_distances[upper.tri(AncSR1_RH_RHRE_distances)]))
t.test(as.numeric(AncSR2_distances[upper.tri(AncSR2_distances)]), 
       as.numeric(AncSR2_RH_RHRE_distances[upper.tri(AncSR2_RH_RHRE_distances)]))


# degree distribution
AncSR1_degrees <- rowSums(AncSR1_distances == 1)
AncSR1_RHRE_degrees <- rowSums(AncSR1_RHRE_distances == 1)
AncSR1_RH_RHRE_degrees <- rowSums(AncSR1_RH_RHRE_distances == 1)  # only RH mutations and RH nodes counted
hist(AncSR1_degrees, breaks = 0:(max(AncSR1_degrees)+1), 
     right = F, main = "AncSR1 degrees", ylim = c(0,25))
hist(AncSR1_RH_RHRE_degrees, breaks = 0:(max(AncSR1_RH_RHRE_degrees)+1), 
     right = F, col = rgb(1,0,0,0.5), add = T)

AncSR2_degrees <- rowSums(AncSR2_distances == 1)
AncSR2_RHRE_degrees <- rowSums(AncSR2_RHRE_distances == 1)
AncSR2_RH_RHRE_degrees <- rowSums(AncSR2_RH_RHRE_distances == 1)  # only RH mutations and RH nodes counted
hist(AncSR2_degrees, breaks = 0:(max(AncSR2_degrees)+1), 
     right = F, main = "AncSR2 degrees", ylim = c(0, 250))
hist(AncSR2_RH_RHRE_degrees, breaks = 0:(max(AncSR2_RH_RHRE_degrees)+1), 
     right = F, col = rgb(1,0,0,0.5), add = T)

mean(AncSR1_degrees)
mean(AncSR1_RHRE_degrees)
mean(AncSR1_RH_RHRE_degrees)

mean(AncSR2_degrees)
mean(AncSR2_RHRE_degrees)
mean(AncSR2_RH_RHRE_degrees)

t.test(AncSR1_degrees, AncSR1_RHRE_degrees)
t.test(AncSR1_degrees, AncSR1_RH_RHRE_degrees)
t.test(AncSR2_degrees, AncSR2_RHRE_degrees)
t.test(AncSR2_degrees, AncSR2_RH_RHRE_degrees)

ks.test(AncSR1_degrees, AncSR1_RHRE_degrees, B = 10000)
ks.test(AncSR2_degrees, AncSR2_RHRE_degrees)

# betweenness distribution
hist(betweenness(AncSR1_graph), freq = FALSE, breaks = seq(0, 3500, 250), 
     main = "AncSR1 bewteenness")
hist(betweenness(AncSR1_RHRE_graph), freq = FALSE, breaks = seq(0, 3500, 250), 
     col = rgb(1,0,0,0.5), add = T)

hist(betweenness(AncSR2_graph), freq = FALSE, breaks = seq(0, 250000, 25000),
     main = "AncSR2 bewteenness")
hist(betweenness(AncSR2_RHRE_graph), freq = FALSE, breaks = seq(0, 250000, 25000),
     col = rgb(1,0,0,0.5), add = T)

mean(betweenness(AncSR1_graph))
mean(betweenness(AncSR1_RHRE_graph))

mean(betweenness(AncSR2_graph))
mean(betweenness(AncSR2_RHRE_graph))
```


How many edges between nodes of the same phenotype vs. different phenotypes?

```{r}
AncSR1_phenotypes <- meanF_data_fxnal %>%
  filter(functional_AncSR1 == T) %>%
  select(AA_var, RE) %>%
  mutate(AA_var = as.character(AA_var), RE = as.character(RE)) %>%
  group_by(AA_var) %>%
  mutate(nfxnal = n(), specificity = replace(RE, nfxnal > 1, "promiscuous")) %>%
  distinct(AA_var, specificity)

AncSR1_network_edges_samediff <- AncSR1_connected %>%
  as.data.frame() %>%
  left_join(AncSR1_phenotypes, by = c("V1" = "AA_var")) %>%
  left_join(AncSR1_phenotypes, by = c("V2" = "AA_var")) %>%
  group_by(specificity.x) %>%
  summarize(nedges_same_phenotype = sum(specificity.x == specificity.y),
            nedges_diff_phenotype = sum(specificity.x != specificity.y)) %>%
  mutate(edges_same_to_diff_ratio = nedges_same_phenotype/nedges_diff_phenotype)
AncSR1_network_edges_samediff
AncSR1_network_edges_samediff %>% 
  filter(nedges_diff_phenotype > 1,
         specificity.x != "promiscuous") %>% 
  summarize(mean = mean(edges_same_to_diff_ratio))

AncSR1_RHRE_network_edges_samediff <- AncSR1_RHRE_connected %>%
  as.data.frame() %>%
  separate_wider_position(V1:V2, names_sep = "_", widths = c("RH" = 4, "RE" = 2)) %>%
  group_by(V1_RE) %>%
  summarize(nedges_same_phenotype = sum(V1_RE == V2_RE),
            nedges_diff_phenotype = sum(V1_RE != V2_RE)) %>%
  mutate(edges_same_to_diff_ratio = nedges_same_phenotype/nedges_diff_phenotype)
AncSR1_RHRE_network_edges_samediff
AncSR1_RHRE_network_edges_samediff %>% 
  semi_join(mutate(AncSR1_network_edges_samediff, specificity.x = str_match(specificity.x, "[ACGT][ACGT]")), 
            by = c("V1_RE" = "specificity.x")) %>%
  filter(nedges_diff_phenotype > 1) %>%
  summarize(mean = mean(edges_same_to_diff_ratio))



AncSR2_phenotypes <- meanF_data_fxnal %>%
  filter(functional_AncSR2 == T) %>%
  select(AA_var, RE) %>%
  mutate(AA_var = as.character(AA_var), RE = as.character(RE)) %>%
  group_by(AA_var) %>%
  mutate(nfxnal = n(), specificity = replace(RE, nfxnal > 1, "promiscuous")) %>%
  distinct(AA_var, specificity)

AncSR2_network_edges_samediff <- AncSR2_connected %>%
  as.data.frame() %>%
  left_join(AncSR2_phenotypes, by = c("V1" = "AA_var")) %>%
  left_join(AncSR2_phenotypes, by = c("V2" = "AA_var")) %>%
  group_by(specificity.x) %>%
  summarize(nedges_same_phenotype = sum(specificity.x == specificity.y),
            nedges_diff_phenotype = sum(specificity.x != specificity.y)) %>%
  mutate(edges_diff_to_same_ratio = nedges_diff_phenotype/nedges_same_phenotype)
AncSR2_network_edges_samediff
AncSR2_network_edges_samediff %>% 
  filter(specificity.x != "promiscuous") %>% 
  summarize(mean = mean(edges_diff_to_same_ratio))
```


## Why EGKA and GSKV?

How many protein variants that are a single mutation away from EGKA in the AncSR1 network and GSKV in the AncSR2 network maintain function?

```{r}

```

