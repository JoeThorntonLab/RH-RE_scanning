---
title: "Phenotype frequency distributions SRE2 corrected"
author: "Jaeda Patton"
date: "2023-10-16"
output: github_document
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE, purl=TRUE}
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=5, fig.height=5, warning = FALSE, 
                      message = FALSE, purl = TRUE)
basedir <- file.path("..", "..")

# check for packages and install any that are missing
packages <- c("tidyr", "ggplot2", "Matrix", "stringr", "tibble", "purrr",
              "MASS", "patchwork", "viridis", "lemon", "ggsignif", "dunn.test", 
              "doParallel", "ggpattern", "ggseqlogo", "ggalluvial", "ggrepel",
              "gplots", "Biostrings", "igraph", "forcats", "magrittr", "scales", 
              "dplyr")
bioconductor_packages <- c()
installed_packages <- packages %in% rownames(installed.packages())
installed_bioc_packages <- bioconductor_packages %in% 
  rownames(installed.packages())

# install packages if running locally (purl = FALSE)
if(any(installed_packages == F)) {
  if(!opts_chunk$get()$purl) install.packages(packages[!installed_packages])
}

if(any(installed_bioc_packages == F)) {
  if(!require("BiocManager", quietly = T)) install.packages("BiocManager")
  BiocManager::install(bioconductor_packages[!installed_bioc_packages])
}

installed_packages <- packages %in% rownames(installed.packages())
installed_bioc_packages <- bioconductor_packages %in% 
  rownames(installed.packages())

# load packages
invisible(lapply(c(bioconductor_packages[installed_bioc_packages], 
                   packages[installed_packages]), 
                 library, character.only=TRUE))


# make output directories
results_dir <- file.path(basedir, "results", 
                         "phenotype_frequency_distributions_SRE2_corrected")
if(!dir.exists(results_dir)) dir.create(results_dir)

# plot fontsize
fontsize <- 16
```


This notebook classifies variants as functional vs. nonfunctional based on their estimated mean fluorescence and analyzes the distribution of phenotypes in each ancestral sequence space (AncSR1 and AncSR2). The mean fluorescence data is generated by the `mutation_effects_model_fitting.Rmd` notebook, with fluorescence estimates coming from four sources:

1. "Binned" variants are those for which we have replicate measurements of fluorescence from the second-round (binned) sort-seq experiment (`data_cleaning.Rmd`).

2. "Debulk" variants are those whose fluorescence is inferred null due to being observed at high frequency in the first-round (debulk) sort-seq experiment and absent in the binned sort-seq experiment (`data_cleaning.Rmd`).

3. "Predicted" variants are those which not observed in either the binned or debulk datasets, whose fluorescence is inferred from the reference free model (`mutation_effects_model_fitting.Rmd`).

4. SRE2 variants, whose original fluorescence came from any of the three sources above. These original fluorescence values have been corrected to account for a general affinity-decreasing effect of the SRE2 background, which is different from that of the other 15 strains (`mutation_effects_model_fitting.Rmd`). (The CC RE strain has yet a different background which likely also has an effect on affinity, but we are unable to estimate the size of this effect. The unmodified fluorescence values are thus used for this strain.)

## Loading data and functions

```{r load, purl = T}
# load general functions
source(file.path(basedir, "scripts", "general_functions.R"))

# reading in cleaned data from binned sort experiment

# reading in complete fluorescence data
AncSR1_meanF_data <- read.csv(file.path(basedir, "results", 
                                        "mutation_effects_model",
                                        "AncSR1_complete_data_corrected.csv.gz"), 
                              stringsAsFactors = TRUE)
AncSR2_meanF_data <- read.csv(file.path(basedir, "results", 
                                        "mutation_effects_model",
                                        "AncSR2_complete_data_corrected.csv.gz"), 
                              stringsAsFactors = TRUE)
meanF_data <- bind_rows(AncSR1 = AncSR1_meanF_data, AncSR2 = AncSR2_meanF_data, 
                        .id = "bg") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  arrange(bg, AA_var, RE)
rm(AncSR1_meanF_data, AncSR2_meanF_data)
```


## How many functional variants are there in each ancestral background?

We define "functional" variants as those with fluorescence at least as high as that of AncSR2-WT:SRE1.

```{r fcutoff, purl = T}
# defining minimum fluorescence cutoff for functional variants
AncSR2WT_SRE1_data <- meanF_data %>% 
  filter(AA_var == "GSKV", bg == "AncSR2", RE == "SRE1 (AA)")
```


To classify variants as functional or nonfunctional, we test whether their fluorescence is significantly lower than that of the reference variant. If it is, then variants are classified as nonfunctional, otherwise they are considered functional.

Since our fluorescence estimates come from different sources (observed vs. inferred), we use different tests to classify the variants whose fluorescence is estimated from the binned sort data, the debulk sort data, and the mutation effects models:

1. Debulk variants are automatically considered nonfunctional (except for SRE2 variants whose original fluorescence estimates were from the debulk sort; these are classified using the method for predicted variants described below). 

2. Binned variants are classified using a two sample t-test, with the null hypothesis that their fluorescence is greater than or equal to that of the reference variant. SRE2 variants whose fluorescence was originally measured in the binned sort experiment are also classified this way, but using the corrected mean fluorescence. The deviations from the mean observed in the original binned sort measurements are taken as the error around the corrected mean.

3. Predicted variants are classified using a nonparametric bootstrap test, with the same null hypothesis as above. This approach takes advantage of the fact that we can use the prediction error observed during model cross-validation as an estimate of the error associated with each predicted variant's fluorescence. For each variant with predicted fluorescence $F_{\text{test}}$, we take the distribution of cross-validation residuals in the interval $F_{\text{test}} \pm 0.1$ as an estimate of the prediction error distribution for that variant. We then create bootstrap fluorescence samples from this distribution and compute the p-value as the fraction of the bootstrap sample with fluorescence greater than or equal to the reference variant. This is done separately for AncSR1 vs. AncSR2 variants, since the models were fit separately for each protein background and thus have different error distributions.

A false-discovery rate of 0.1 is used for multiple testing correction.

```{r pfunctionalbinned, purl = FALSE}
# Compute p-value for calling variants functional that were observed in the 
# binned sort experiment.
#
# H0: Variant is at least as fluorescent as reference variant.
# HA: Variant is less fluorescent than reference variant.
# Use a t-test and FDR-adjusted p-value. Variants with padj < 0.1 are called nonfunctional.

if(!file.exists(file.path(results_dir, "pbinned.rda"))) {
  data <- meanF_data %>%
    filter(type == "binned", RE == "SRE2 (GA)") %>%
    mutate(orig_meanF = rowMeans(select(., meanF_REP1:meanF_REP4), na.rm = TRUE),
           meanF_REP1 = avg_meanF + (meanF_REP1 - orig_meanF),
           meanF_REP2 = avg_meanF + (meanF_REP2 - orig_meanF),
           meanF_REP3 = avg_meanF + (meanF_REP3 - orig_meanF),
           meanF_REP4 = avg_meanF + (meanF_REP4 - orig_meanF)) %>%
    select(-orig_meanF) %>%
    bind_rows(filter(meanF_data, type == "binned", RE != "SRE2 (GA)")) %>%
    arrange(bg, AA_var, RE)
  
  pbinned <- apply(select(data, meanF_REP1:meanF_REP4), 1, function(x)
      t.test(as.numeric(x), 
             as.numeric(select(AncSR2WT_SRE1_data, meanF_REP1:meanF_REP4)),
             "less", na.action = "na.omit")$p.value)
  
  save(pbinned, file = file.path(results_dir, "pbinned.rda"))
} else load(file.path(results_dir, "pbinned.rda"))
```

```{r pfunctionalpredictedAncSR1, purl = FALSE}
# For variants with predicted fluorescence from reference-free model, test for
# fluorescence less than the reference with a nonparametric bootstrap test,
# where bootstrapped fluorescence samples are taken from the cross-validation
# error distribution for variants with fluorescence similar to that of the test
# variant. This method helps to account for the non-normal error distributions
# observed for high predicted fluorescence values.
#
# H0: Variant is at least as fluorescent as reference variant.
# HA: Variant is less fluorescent than reference variant.
# Adjust p-value using FDR correction. Variants with padj < 0.1 are called 
# nonfunctional.

# First test AncSR1 predicted variants

# first load the cross-validation fits from the model fitting
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR1.cv.pred.fine.rda"))
load(file.path(basedir, "results", "mutation_effects_model", "AncSR1_foldid.rda"))
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR1_model_data.rda"))
AncSR1.cv.pred <- lapply(AncSR1.cv.pred.fine, function(x) as.numeric(x[,10]))

AncSR1.cv.obs <- lapply(1:10, function(x) 
  AncSR1_model_data$avg_meanF[AncSR1_foldid == x])

rm(AncSR1.cv.pred.fine, AncSR1_foldid, AncSR1_model_data)

# concatenate fits across all 10 cross-validation folds
AncSR1.cv <- data.frame(pred = unlist(AncSR1.cv.pred, use.names = FALSE),
                        obs = unlist(AncSR1.cv.obs, use.names = FALSE))

# plot concatentated predicted vs. observed fluorescence
ggplot(AncSR1.cv, aes(x = pred, y = obs)) +
  geom_bin2d(bins = 50) +
  scale_fill_viridis(trans = "log10", name = "Variants",
                     labels = label_comma()) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Predicted fluorescence", y = "Observed fluorescence", 
       title = "AncSR1 cross-validation fits, concatenated") +
  theme_classic()

# compute residuals
AncSR1.cv$res <- AncSR1.cv$pred - AncSR1.cv$obs

# Bootstrap predicted fluorescence based on CV error distributions. For each
# predicted variant, sample from the distribution of CV residuals concatenated
# across all 10 CV folds, within a range of +/- 0.1 of the predicted
# fluorescence. Sample 250 bootstrap samples per replicate.

if(!file.exists(file.path(results_dir, "bspred.AncSR1.rda"))) {
  # parallel processing
  cores <- 24
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  bspred.AncSR1 <- foreach(i = 1:cores, .combine = 'cbind') %dopar% {
    data <- meanF_data %>% 
      filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR1")
    
    # split data into chunks
    size <- nrow(data)
    chunksize <- ceiling(size / cores)
    chunk <- data[((i - 1) * chunksize + 1):min(i * chunksize, size),]
    
    # create bootstrap reps
    sapply(chunk$avg_meanF, function(x) {
      # residual distribution centered around meanF of test variant
      res <- AncSR1.cv %>% filter(pred > x - 0.1 & pred < x + 0.1) %>% pull(res)
      # bootstrap
      sample(x + res, 250, replace = TRUE)
    })
  }
  stopCluster(cl)
  colnames(bspred.AncSR1) <- meanF_data %>% 
    filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR1") %>% 
    select(AA_var, RE) %>%
    unite(AA_var, RE, col = "var") %>% pull(var)
  save(bspred.AncSR1, file = file.path(results_dir, "bspred.AncSR1.rda"))
} else load(file.path(results_dir, "bspred.AncSR1.rda"))

# Compute p-value for functional variants as fraction of bootstrap replicates
# that are greater than or equal to that of the mean AncSR2:SRE1 WT variant.
if(!file.exists(file.path(results_dir, "ppredicted.AncSR1.rda"))) {
  ppredicted.AncSR1 <- apply(bspred.AncSR1, 2, function(x) 
    sum(x >= AncSR2WT_SRE1_data$avg_meanF) / 250)
  save(ppredicted.AncSR1, file = file.path(results_dir, "ppredicted.AncSR1.rda"))
} else load(file.path(results_dir, "ppredicted.AncSR1.rda"))

rm(bspred.AncSR1)
```

```{r pfunctionalpredictedAncSR2, purl = TRUE}
# Repeat for AncSR2 predicted variants

# first load the cross-validation fits from the model fitting
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR2.cv.pred.fine.rda"))
load(file.path(basedir, "results", "mutation_effects_model", "AncSR2_foldid.rda"))
load(file.path(basedir, "results", "mutation_effects_model", 
               "AncSR2_model_data.rda"))
AncSR2.cv.pred <- lapply(AncSR2.cv.pred.fine, function(x) as.numeric(x[,13]))

AncSR2.cv.obs <- lapply(1:10, function(x)
  AncSR2_model_data$avg_meanF[AncSR2_foldid == x])

rm(AncSR2.cv.pred.fine, AncSR2_foldid, AncSR2_model_data)

# concatenate fits across all 10 cross-validation folds
AncSR2.cv <- data.frame(pred = unlist(AncSR2.cv.pred, use.names = FALSE),
                        obs = unlist(AncSR2.cv.obs, use.names = FALSE))

# plot concatentated predicted vs. observed fluorescence
ggplot(AncSR2.cv, aes(x = pred, y = obs)) +
  geom_bin2d(bins = 50) +
  scale_fill_viridis(trans = "log10", name = "Variants",
                     labels = label_comma()) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Predicted fluorescence", y = "Observed fluorescence", 
       title = "AncSR2 cross-validation fits, concatenated") +
  theme_classic()

# compute residuals
AncSR2.cv$res <- AncSR2.cv$pred - AncSR2.cv$obs
# Bootstrap predicted fluorescence based on CV error distributions. For each
# predicted variant, sample from the distribution of CV residuals concatenated
# across all 10 CV folds, within a range of +/- 0.1 of the predicted
# fluorescence. Sample 250 bootstrap samples per replicate.

if(!file.exists(file.path(results_dir, "bspred.AncSR2.rda"))) {
  # parallel processing
  cores <- 24
  cl <- parallel::makeCluster(cores, "FORK", outfile = "")
  registerDoParallel(cl)
  bspred.AncSR2 <- foreach(i = 1:cores, .combine = 'cbind') %dopar% {
    data <- meanF_data %>% 
      filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
             bg == "AncSR2")
    
    # split data into chunks
    size <- nrow(data)
    chunksize <- ceiling(size / cores)
    chunk <- data[((i - 1) * chunksize + 1):min(i * chunksize, size),]
    
    # create bootstrap reps
    sapply(chunk$avg_meanF, function(x) {
      # residual distribution centered around meanF of test variant
      res <- AncSR2.cv %>% filter(pred > x - 0.1 & pred < x + 0.1) %>% pull(res)
      # bootstrap
      sample(x + res, 250, replace = TRUE)
    })
  }
  stopCluster(cl)
  colnames(bspred.AncSR2) <- meanF_data %>% 
    filter((type == "predicted" | (type == "debulk" & RE == "SRE2 (GA)")), 
           bg == "AncSR2") %>% 
    select(AA_var, RE) %>%
    unite(AA_var, RE, col = "var") %>% pull(var)
  save(bspred.AncSR2, file = file.path(results_dir, "bspred.AncSR2.rda"))
} else load(file.path(results_dir, "bspred.AncSR2.rda"))

# Compute p-value for functional variants as fraction of bootstrap replicates
# that are greater than or equal to that of the mean AncSR2:SRE1 WT variant.
if(!file.exists(file.path(results_dir, "ppredicted.AncSR2.rda"))) {
  ppredicted.AncSR2 <- apply(bspred.AncSR2, 2, function(x) 
    sum(x >= AncSR2WT_SRE1_data$avg_meanF) / 250)
  save(ppredicted.AncSR2, file = file.path(results_dir, "ppredicted.AncSR2.rda"))
} else load(file.path(results_dir, "ppredicted.AncSR2.rda"))

rm(bspred.AncSR2)
```

```{r classifyfunctional, purl = FALSE, fig.width = 8}
# classify variants as functional if padj >= 0.1 (not significantly less 
# fluorescent than AncSR2:SRE1 WT)
meanF_data <- rbind(meanF_data %>% 
                      filter(type == "binned") %>%
                      mutate(p = pbinned),
                    meanF_data %>%
                      filter(type == "predicted" | 
                               (type == "debulk" & RE == "SRE2 (GA)"), 
                             bg == "AncSR1") %>%
                      mutate(p = ppredicted.AncSR1),
                    meanF_data %>%
                      filter(type == "predicted" | 
                               (type == "debulk" & RE == "SRE2 (GA)"), 
                             bg == "AncSR2") %>%
                      mutate(p = ppredicted.AncSR2),
                    meanF_data %>%
                      filter(type == "debulk" & RE != "SRE2 (GA)") %>%
                      mutate(p = 0)) %>%
  mutate(padj = p.adjust(p, "fdr"), functional = padj >= 0.1) %>%
  arrange(bg, AA_var, RE)

# export data
write.csv(meanF_data %>% filter(functional) %>% select(bg:meanF_REP4), 
          file = gzfile(file.path(results_dir, "meanF_data_fxnal.csv.gz"), 
                        compression = 9),
          row.names = FALSE)

# plot histogram of fluorescence colored by functional vs. not functional, as
# as well as source of fluorescence estimate (binned sort, debulk sort, or 
# predicted)
ggplot(meanF_data, aes(x = avg_meanF, fill = type, alpha = functional)) +
  geom_histogram(position = "stack") +
  scale_y_continuous(trans = log10plus1, name = "Count + 1") +
  scale_alpha_manual(values = c(0.6, 1)) +
  geom_vline(xintercept = AncSR2WT_SRE1_data$avg_meanF, 
             color = "gray30", linetype = 2) +
  facet_grid(cols = vars(bg)) +
  theme_classic() +
  labs(x = "Fluorescence")

# same histogram just for functional variants
ggplot(filter(meanF_data, functional), aes(x = avg_meanF, fill = type)) +
  geom_histogram(position = "identity", alpha = 0.75) +
  scale_y_continuous() +
  geom_vline(xintercept = AncSR2WT_SRE1_data$avg_meanF, 
             color = "gray30", linetype = 2) +
  facet_grid(cols = vars(bg)) +
  theme_classic() +
  labs(x = "Fluorescence")

# plot fluorescence estimate source by RE for functional variants
meanF_data %>%
  filter(functional) %>%
  ggplot(aes(x = RE, fill = type)) +
  geom_bar() +
  facet_grid(rows = vars(bg), scales = "free_y") +
  theme_classic() +
  ylab("Number of functional variants") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```

The histograms above show the distribution of fluorescence for variants classified as functional vs. nonfunctional. The vertical dashed line shows the fluorescence of the reference variant. 

Let's look at the number of variants classified as functional on each ancestral background.

```{r countfxnalvars, purl = FALSE, fig.width = 4}
# print number of variants (protein:RE) classified as functional on each 
# background
meanF_data %>%
  group_by(bg, type) %>%
  filter(type != "debulk") %>%
  summarize(count = sum(functional)) %>%
  pivot_wider(names_from = type, values_from = count) %>%
  mutate(all = binned + predicted, fraction.total = all / 2560000) %>%
  knitr::kable(caption = "Number of functional protein:RE variants")

# plot as bar plot
fxnalproteinREbgplot <- meanF_data %>%
  filter(functional) %>%
  ggplot(aes(x = bg, fill = bg)) +
  geom_bar() +
  scale_y_continuous(name = "Number of functional variants",
                     breaks = breaks_extended(6),
                     # sec.axis = sec_axis(trans = ~ . / (160000*16), 
                     #                     name = "Fraction of all possible"),
                     expand = expansion(mult = c(0.05, 0.1))
                     ) +
  # geom_text(stat = "count", 
  #           aes(label = paste0(..count.., " (", 
  #                              signif(..count.. / 2560000 * 100, 2), "%)")), 
  #           vjust = -1, size = 4) +
  geom_text(stat = "count",
            aes(label = paste0(signif(after_stat(count) / 2560000 * 100, 2), "%")),
            vjust = -1, size = 4) +
  scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(x = "", title = "Protein:RE variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))

# print number of protein variants classified as functional on each background
meanF_data %>%
  group_by(bg, AA_var) %>%
  summarize(functional = sum(functional) > 0) %>%
  group_by(bg) %>%
  summarize(count = sum(functional)) %>%
  mutate(fraction.total = count / 160000) %>%
  knitr::kable(caption = "Number of functional protein variants")

# plot as bar plot
fxnalproteinbgplot <- meanF_data %>%
  group_by(bg, AA_var) %>%
  summarize(functional = sum(functional) > 0) %>%
  filter(functional) %>%
  ggplot(aes(x = bg, fill = bg)) +
  geom_bar() +
  scale_y_continuous(name = "Number of functional variants",
                     breaks = breaks_extended(6),
                     # sec.axis = sec_axis(trans = ~ . / (160000), 
                     #                     name = "Fraction of all possible"),
                     expand = expansion(mult = c(0.05, 0.1))
                     ) +
  # geom_text(stat = "count", 
  #           aes(label = paste0(..count.., " (", 
  #                              signif(..count.. / 160000 * 100, 2), "%)")), 
  #           vjust = -1, size = 4) +
  geom_text(stat = "count",
            aes(label = paste0(signif(after_stat(count) / 160000 * 100, 2), "%")),
            vjust = -1, size = 4) +
  scale_fill_manual(values = bg_color(), drop = FALSE) +
  labs(x = "", title = "Protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "none") +
  guides(x = guide_axis(angle = 45))

fxnalproteinREbgplot + plot_spacer() + fxnalproteinbgplot + 
  plot_layout(widths = c(2, 0.5, 2))
```



```{r, purl = FALSE, eval = F}
# histogram of fluorescence colored by FDR <= 0.15
# meanF_data_active %>%
#   ggplot(aes(x = avg_meanF, fill = padjfunctional <= 0.15)) +
#   geom_histogram() +
#   geom_vline(xintercept = AncSR2WT_SRE1_data$avg_meanF) +  # fluorescence of reference
#   theme_classic() +
#   labs(title = "active variants", x = "fluorescence", fill = "significant")
# 
# meanF_data_functional <- meanF_data_active %>% filter(padjfunctional > 0.15)
```


## What is the mechanism behind more functional variants in the AncSR2 vs. AncSR1 background?

```{r meanF_data_fxnal, purl = FALSE}
# get protein:RE variants that are functional in both backgrounds
meanF_data_fxnal <- meanF_data %>%
  select(bg:avg_meanF, type, meanF_REP1:meanF_REP4, functional, active) %>%
  pivot_wider(names_from = bg, values_from = avg_meanF:active) %>%
  filter(functional_AncSR1 | functional_AncSR2)
```

```{r permissivemech, purl = FALSE, fig.width = 7, eval = FALSE}
# How many variants that are functional in at least one ancestral background 
# have higher fluorescence in AncSR2? Use a nonparametric bootstrap test (like 
# the one used above for classifying functional variants) for variants with 
# model-predicted fluorescence in at least one background; for all others, use a 
# t-test.
if(!file.exists(file.path(results_dir, "phigherAncSR2.rda"))) {
  nbootstrap <- 1000
  # phigherAncSR2 <- numeric(length = nrow(meanF_data_fxnal))
  for(i in 1:nrow(meanF_data_fxnal)) {
    # if fluorescence is from binned sort in both backgrounds, use a t-test
    if(meanF_data_fxnal$type_AncSR1[i] == "binned" && 
       meanF_data_fxnal$type_AncSR2[i] == "binned") {
      next
      p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR1", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR2", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  alternative = "less",
                  na.action = "na.omit")$p.value
    } 
    # if fluorescence is model-predicted in either background, use bootstrap test
    else if(meanF_data_fxnal$type_AncSR1[i] == "predicted" ||
              meanF_data_fxnal$type_AncSR2[i] == "predicted") {
      next
      meanF_AncSR1 <- meanF_data_fxnal$avg_meanF_AncSR1[i]
      meanF_AncSR2 <- meanF_data_fxnal$avg_meanF_AncSR2[i]
      if(meanF_data_fxnal$type_AncSR1[i] == "predicted") {
        # residual distribution centered around meanF of AncSR1 test variant
        res <- AncSR1.cv %>% 
          filter(pred > meanF_AncSR1 - 0.1 & pred < meanF_AncSR1 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR1 <- sample(meanF_AncSR1 + res, nbootstrap, replace = TRUE)
      }
      if(meanF_data_fxnal$type_AncSR2[i] == "predicted") {
        # residual distribution centered around meanF of AncSR2 test variant
        res <- AncSR2.cv %>% 
          filter(pred > meanF_AncSR2 - 0.1 & pred < meanF_AncSR2 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR2 <- sample(meanF_AncSR2 + res, nbootstrap, replace = TRUE)
      }
      p <- sum(meanF_AncSR1 >= meanF_AncSR2) / nbootstrap
    } 
    # otherwise one variant must have fluorescence inferred from binned sort and
    # the other from debulk sort; use a one-sample t-test
    else {
      if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>%
                      select(grep("meanF_REP._AncSR2",
                                  colnames(meanF_data_fxnal),
                                  value = T)),
                    alternative = "greater",
                    mu = meanF_data_fxnal$avg_meanF_AncSR1[i],
                    na.action = "na.omit")$p.value
      } else {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                      select(grep("meanF_REP._AncSR1", 
                                  colnames(meanF_data_fxnal), 
                                  value = T)),
                    alternative = "less",
                    mu = meanF_data_fxnal$avg_meanF_AncSR2[i],
                    na.action = "na.omit")$p.value
      }
    }
    # # if fluorescence inferred null in AncSR1 from debulk sort, use a t-test
    # else if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
    #   p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
    #                 select(grep("meanF_REP._AncSR2", 
    #                             colnames(meanF_data_fxnal), 
    #                             value = T)),
    #               alternative = "greater",
    #               mu = meanF_data_fxnal$avg_meanF_AncSR1[i],
    #               na.action = "na.omit")$p.value
    # } 
    # # if fluorescence is inferred null in AncSR2 from debulk sort, then it cannot 
    # # be higher in AncSR1
    # else if(meanF_data_fxnal$type_AncSR2[i] == "debulk") {
    #   p <- 1
    # }
    phigherAncSR2[i] <- p
  }
  
  save(phigherAncSR2, file = file.path(results_dir, "phigherAncSR2.rda"))
} else load(file.path(results_dir, "phigherAncSR2.rda"))

# FDR correction
padjhigherAncSR2 <- p.adjust(phigherAncSR2, "fdr")
print(paste("variants with higher fluorescence in AncSR2:", 
            sum(padjhigherAncSR2 < 0.05)))
print(paste("Fraction variants with higher fluorescence in AncSR2 out of those that are functional in either background:", 
            sum(padjhigherAncSR2 < 0.05) / nrow(meanF_data_fxnal)))

# plot fluorescence in each background colored by significance
bgfluorscatterplot <- meanF_data_fxnal %>%
  mutate(padj = padjhigherAncSR2) %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  scale_color_discrete(labels = c(paste0("Not significant (", 
                                         signif((1 - sum(padjhigherAncSR2 < 0.05) / 
                                                   nrow(meanF_data_fxnal)) * 100, 2), "%)"),
                                  paste0("Significant (", 
                                         signif(sum(padjhigherAncSR2 < 0.05) / 
                                                  nrow(meanF_data_fxnal) * 100, 2), "%)")),
                       name = "Higher fluorescence in\nAncSR2 background") +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplot

# replot, split by ERE variants vs. non-ERE variants
bgfluorscatterplotnonERE <- meanF_data_fxnal %>%
  mutate(padj = padjhigherAncSR2) %>%
  filter(RE != "ERE (GT)") %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  # scale_color_discrete(labels = c(paste0("Not significant (", 
  #                                        signif((1 - sum(padjhigherAncSR2 < 0.05) / 
  #                                                  nrow(meanF_data_fxnal)) * 100, 2), "%)"),
  #                                 paste0("Significant (", 
  #                                        signif(sum(padjhigherAncSR2 < 0.05) / 
  #                                                 nrow(meanF_data_fxnal) * 100, 2), "%)")),
  #                      name = "Higher fluorescence in\nAncSR2 background") +
  scale_color_discrete(labels = c("Not significant", "Significant"), 
                       name = "Higher fluorescence in\nAncSR2 background") +
  labs(title = "non-ERE variants",
       x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplotERE <- meanF_data_fxnal %>%
  mutate(padj = padjhigherAncSR2) %>%
  filter(RE == "ERE (GT)") %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  # scale_color_discrete(labels = c(paste0("Not significant (", 
  #                                        signif((1 - sum(padjhigherAncSR2 < 0.05) / 
  #                                                  nrow(meanF_data_fxnal)) * 100, 2), "%)"),
  #                                 paste0("Significant (", 
  #                                        signif(sum(padjhigherAncSR2 < 0.05) / 
  #                                                 nrow(meanF_data_fxnal) * 100, 2), "%)")),
  #                      name = "Higher fluorescence in\nAncSR2 background") +
  scale_color_discrete(labels = c("Not significant", "Significant"), 
                       name = "Higher fluorescence in\nAncSR2 background") +
  labs(title = "ERE variants",
       x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterplotnonERE + bgfluorscatterplotERE + plot_layout(guides = "collect")

bgfluorscatterbyRE <- meanF_data_fxnal %>%
  mutate(padj = padjhigherAncSR2) %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.05)) +
  geom_point(alpha = 0.5) +
  facet_wrap(vars(RE)) +
  scale_color_discrete(labels = c("Not significant", "Significant"), 
                       name = "Higher fluorescence in\nAncSR2 background\nFDR = 0.05") +
  labs(x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterbyRE

meanF_data_fxnal %>%
  mutate(padj = padjhigherAncSR2 < 0.05) %>%
  group_by(RE, padj) %>%
  count() %>%
  group_by(RE) %>%
  mutate(frac = n / sum(n)) %>%
  filter(padj)


# boxplot of the distribution of fluorescence in each background; p-value from 
# Wilcoxon paired-sample test
bgfluorboxplot <- meanF_data_fxnal %>%
  select(AA_var:avg_meanF_AncSR2) %>%
  pivot_longer(3:4, names_to = "bg", names_prefix = "avg_meanF_", 
               values_to = "avg_meanF") %>%
  ggplot(aes(x = bg, y = avg_meanF, fill = bg)) +
  # geom_violin(width = 2, draw_quantiles = c(0.25, 0.5, 0.75)) +
  stat_boxplot() +
  # stat_summary(geom = "point", fun = "median") +
  geom_signif(comparisons = list(c("AncSR1", "AncSR2")), test = "wilcox.test",
              test.args = list(alternative = "less", paired = TRUE), 
              map_signif_level = TRUE) +
  scale_fill_manual(values = bg_color(), drop = FALSE) +
  xlab("Ancestral background") +
  ylab("Fluorescence") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "none")
bgfluorboxplot

# boxplots of the distribution of fluorescence in each background, plotted 
# separately for each RE; p-value from Wilcoxon paired-sample test
bgREfluorboxplot <- meanF_data_fxnal %>%
  select(AA_var:avg_meanF_AncSR2) %>%
  pivot_longer(3:4, names_to = "bg", names_prefix = "avg_meanF_", 
               values_to = "avg_meanF") %>%
  ggplot(aes(x = bg, y = avg_meanF, fill = bg)) +
  # geom_violin() +
  stat_boxplot(outlier.size = 1) +
  facet_wrap(vars(RE), nrow = 2) +
  geom_signif(comparisons = list(c("AncSR1", "AncSR2")), test = "wilcox.test",
              test.args = list(alternative = "less", paired = TRUE), 
              map_signif_level = TRUE, textsize = 3) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  xlab("") +
  ylab("Fluorescence") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.position = "right",
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        strip.text = element_text(size = fontsize - 8))
bgREfluorboxplot

# adjusted p-values for RE-wise Wilcoxon test
phigherAncSR2RE <- sapply(sort(unique(meanF_data_fxnal$RE)), function(x) {
  data <- meanF_data_fxnal %>% filter(RE == x)
  wilcox.test(data$avg_meanF_AncSR1, data$avg_meanF_AncSR2, alternative = "less",
              paired = TRUE)$p.value
})
padjhigherAncSR2RE <- p.adjust(phigherAncSR2RE, "fdr")
# check whether FDR < 0.05 for RE-wise Wilcoxon test
print(sum(padjhigherAncSR2RE < 0.05))
```


Which variants have significantly *lower* expression in the AncSR2 background?

```{r, purl = FALSE, eval = FALSE}
# How many variants that are functional in at least one ancestral background 
# have lower fluorescence in AncSR2? Use a nonparametric bootstrap test (like 
# the one used above for classifying functional variants) for variants with 
# model-predicted fluorescence in at least one background; for all others, use a 
# t-test.
if(!file.exists(file.path(results_dir, "plowerAncSR2.rda"))) {
  nbootstrap <- 1000
  plowerAncSR2 <- numeric(length = nrow(meanF_data_fxnal))
  for(i in 1:nrow(meanF_data_fxnal)) {
    # if fluorescence is from binned sort in both backgrounds, use a two-sample 
    # t-test
    if(meanF_data_fxnal$type_AncSR1[i] == "binned" && 
       meanF_data_fxnal$type_AncSR2[i] == "binned") {
      p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR1", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  meanF_data_fxnal %>% slice(i) %>% 
                    select(grep("meanF_REP._AncSR2", 
                                colnames(meanF_data_fxnal), 
                                value = T)),
                  alternative = "greater",
                  na.action = "na.omit")$p.value
    } 
    # if fluorescence is model-predicted in either background, use bootstrap test
    else if(meanF_data_fxnal$type_AncSR1[i] == "predicted" ||
              meanF_data_fxnal$type_AncSR2[i] == "predicted") {
      meanF_AncSR1 <- meanF_data_fxnal$avg_meanF_AncSR1[i]
      meanF_AncSR2 <- meanF_data_fxnal$avg_meanF_AncSR2[i]
      if(meanF_data_fxnal$type_AncSR1[i] == "predicted") {
        # residual distribution centered around meanF of AncSR1 test variant
        res <- AncSR1.cv %>% 
          filter(pred > meanF_AncSR1 - 0.1 & pred < meanF_AncSR1 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR1 <- sample(meanF_AncSR1 + res, nbootstrap, replace = TRUE)
      }
      if(meanF_data_fxnal$type_AncSR2[i] == "predicted") {
        # residual distribution centered around meanF of AncSR2 test variant
        res <- AncSR2.cv %>% 
          filter(pred > meanF_AncSR2 - 0.1 & pred < meanF_AncSR2 + 0.1) %>% 
          pull(res)
        # bootstrap
        meanF_AncSR2 <- sample(meanF_AncSR2 + res, nbootstrap, replace = TRUE)
      }
      p <- sum(meanF_AncSR2 >= meanF_AncSR1) / nbootstrap
    } 
    # otherwise one variant must have fluorescence inferred from binned sort and
    # the other from debulk sort; use a one-sample t-test
    else {
      if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>%
                      select(grep("meanF_REP._AncSR2",
                                  colnames(meanF_data_fxnal),
                                  value = T)),
                    alternative = "less",
                    mu = meanF_data_fxnal$avg_meanF_AncSR1[i],
                    na.action = "na.omit")$p.value
      } else {
        p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
                      select(grep("meanF_REP._AncSR1", 
                                  colnames(meanF_data_fxnal), 
                                  value = T)),
                    alternative = "greater",
                    mu = meanF_data_fxnal$avg_meanF_AncSR2[i],
                    na.action = "na.omit")$p.value
      }
    }
    # # if fluorescence inferred null in AncSR2 from debulk sort, use a t-test
    # else if(meanF_data_fxnal$type_AncSR2[i] == "debulk") {
    #   p <- t.test(meanF_data_fxnal %>% slice(i) %>% 
    #                 select(grep("meanF_REP._AncSR1", 
    #                             colnames(meanF_data_fxnal), 
    #                             value = T)),
    #               alternative = "greater",
    #               mu = meanF_data_fxnal$avg_meanF_AncSR2[i],
    #               na.action = "na.omit")$p.value
    # } 
    # # if fluorescence is inferred null in AncSR1 from debulk sort, then it cannot 
    # # be higher in AncSR2
    # else if(meanF_data_fxnal$type_AncSR1[i] == "debulk") {
    #   p <- 1
    # }
    plowerAncSR2[i] <- p
  }
  
  save(plowerAncSR2, file = file.path(results_dir, "plowerAncSR2.rda"))
} else load(file.path(results_dir, "plowerAncSR2.rda"))
padjlowerAncSR2 <- p.adjust(plowerAncSR2, method = "fdr")

bgfluorscatterbyRElowerAncSR2 <- meanF_data_fxnal %>%
  mutate(p = plowerAncSR2, padj = padjlowerAncSR2) %>%
  # filter(type_AncSR1 == "binned", type_AncSR2 == "binned") %>%
  ggplot(aes(x = avg_meanF_AncSR1, y = avg_meanF_AncSR2, color = padj < 0.2)) +
  geom_point(alpha = 0.5) +
  facet_wrap(vars(RE)) +
  scale_color_discrete(labels = c("Not significant", "Significant"), 
                       name = "Lower fluorescence in\nAncSR2 background,\nFDR = 0.2") +
  labs(title = "ERE variants",
       x = "Fluorescence in AncSR1 background",
       y = "Fluorescence in AncSR2 background") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
bgfluorscatterbyRElowerAncSR2

meanF_data_fxnal %>%
  ungroup() %>%
  mutate(padj = padjlowerAncSR2 < 0.2) %>%
  count(RE, padj) %>%
  complete(RE, padj, fill = list(n = 0)) %>%
  group_by(RE) %>%
  mutate(frac = n / sum(n)) %>%
  filter(padj)
```



## How many functional protein variants bind to each RE?

Let's now count the number of functional protein variants that bind to each RE variant.

```{r countfxnalRE, purl = FALSE}
nboundRE <- meanF_data %>%
  group_by(bg, RE) %>%
  summarize(n = sum(functional)) %>%
  ungroup() %>%
  complete(bg, RE, fill = list(n = 0))

nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  mutate(nincreaseAncSR2 = AncSR2 - AncSR1,
         foldincreaseAncSR2 = round(AncSR2 / AncSR1, 1)) %>%
  knitr::kable(caption = "Number of functional protein variants per RE")
```

Plot number of functional variants per RE.

```{r plotfxnalRE, purl = FALSE, fig.height = 6, fig.width = 7}
# bar plot (AncSR1 on top, AncSR2 on bottom)
fxnalREbarplotfacet <- nboundRE %>%
  ggplot(aes(x = RE, y = n, fill = bg)) +
  geom_col() +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))

fxnalREbarplotfacet

# bar plot (AncSR1/AncSR2 bars dodged)
fxnalREbarplotdodge <- nboundRE %>%
  ggplot(aes(x = RE, y = n, fill = bg)) +
  geom_col(position = "dodge") +
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))

fxnalREbarplotdodge

# scatter plot
fxnalREscatterplot <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  ggplot(aes(x = AncSR1, y = AncSR2)) +
  geom_smooth(method = "lm", color = "red") +
  geom_point() +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  labs(x = "Number of protein variants bound in AncSR1 background",
       y = "Number of protein variants bound in AncSR2 background") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
fxnalREscatterplot

# fitting linear model to number of protein variants bound per RE in each bg
nfxnalbglm <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  column_to_rownames("RE") %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbglm)
# outlier detection
par(mfrow = c(2,2))
plot(nfxnalbglm)  # ERE is likely an extreme outlier, and SRE1 a moderate outlier
cooksD <- cooks.distance(nfxnalbglm)
print(cooksD)
outliers <- cooksD[cooksD > (3 * mean(cooksD, na.rm = TRUE))]
print(outliers)
# refit model with outlier removed
nfxnalbglmnooutliers <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  filter(!RE %in% names(outliers)) %>%
  column_to_rownames("RE") %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbglmnooutliers)

# replot, show linear fit with outlier removed
fxnalREscatterplotnooutlier <- nboundRE %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  ggplot(aes(x = AncSR1, y = AncSR2)) +
  geom_smooth(data = . %>% filter(!RE %in% names(outliers)),
              method = "lm", color = "red", fullrange = TRUE) +
  geom_point() +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  labs(x = "Number of protein variants bound in AncSR1 background",
       y = "Number of protein variants bound in AncSR2 background") +
  theme(text = element_text(size = fontsize)) +
  theme_classic()
fxnalREscatterplotnooutlier

nfxnalbgnoERESRE1lm <- nboundRE %>%
  filter(!RE %in% c("ERE (GT)", "SRE1 (AA)")) %>%
  pivot_wider(names_from = bg, values_from = n) %>%
  lm(formula = AncSR2 ~ AncSR1, data = .)
summary(nfxnalbgnoERESRE1lm)

# # number of functional protein:RE variants on each background
# a <- meanF_data_functional %>%
#   group_by(bg) %>%
#   count() %>%
#   ggplot(aes(x = bg, y = n, fill = bg)) +
#   geom_col(width = 0.9) +
#   geom_text(aes(label = n), vjust = -0.5, color = "black", size = 3.5) +
#   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
#   scale_fill_manual(values = bg_color(), drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   labs(x = "Ancestral\nbackground", 
#        y = "number of functional\nprotein:response element variants") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.position = "none") +
#   guides(x = guide_axis(angle = 45))
# 
# # number of functional protein variants on each background
# a2 <- meanF_data_functional %>%
#   group_by(bg) %>%
#   distinct(AA_var, .keep_all = TRUE) %>%
#   count() %>%
#   ggplot(aes(x = bg, y = n, fill = bg)) +
#   geom_col(width = 0.9) +
#   # geom_text(aes(label = n), vjust = -0.5, color = "black", size = 3.5) +
#   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
#   scale_fill_manual(values = bg_color(), drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   labs(x = "Ancestral\nbackground", 
#        y = "number of bound protein variants") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.position = "none") +
#   guides(x = guide_axis(angle = 45))
# 
# # number of functional variants on each background that bind to each RE
# b <- meanF_data_functional %>%
#   group_by(bg, RE) %>%
#   count() %>%
#   mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
#   ggplot(aes(x = RE, y = n, fill = bg)) +
#   geom_col(width = 0.9) +
#   facet_grid(rows = vars(bg), scales = "free") +
#   scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
#   scale_fill_manual(values = bg_color(), drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   # geom_text(aes(label = n), vjust = -0.5, color = "black", size = 3.5) +
#   labs(x = "Response element", y = "Number of bound protein variants", 
#        fill = "Ancestral\nbackground") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.text = element_text(size = 14),
#         strip.background = element_blank(),
#         strip.text.y = element_blank(),
#         legend.position = c(0.9, 0.9)) +
#   guides(x = guide_axis(angle = 45))
# 
# # same as b but plotting the backgrounds next to each other
# b2 <- meanF_data_functional %>%
#   group_by(bg, RE) %>%
#   count() %>%
#   ungroup() %>%
#   complete(bg, RE, fill = list(n = 0)) %>%
#   mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
#   ggplot(aes(x = RE, y = n, fill = bg)) +
#   geom_col(width = 0.9, position = "dodge") +
#   # geom_text(aes(label = n), vjust = -0.5, color = "black",
#   #           size = 3.5, position = position_dodge(width = 0.9)) +
#   scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
#   scale_fill_manual(values = bg_color(), drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   labs(x = "Response element", y = "Number of bound protein variants", 
#        fill = "Ancestral\nbackground") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.text = element_text(size = 14),
#         strip.background = element_blank(),
#         strip.text.y = element_blank(),
#         legend.position = c(0.9, 0.9)) +
#   guides(x = guide_axis(angle = 45))
# 
# a + plot_spacer() + b + plot_layout(widths = c(1, 0.5, 5))
# a2 + plot_spacer() + b + plot_layout(widths = c(1, 0.5, 10))
# a2 + plot_spacer() + b2 + plot_layout(widths = c(1, 0.5, 10))
```


```{r, purl = FALSE, eval = F}
# # get number of protein variants that bind each RE in only AncSR1 background,
# # only AncSR2 background, or both backgrounds
# variants_bound_by_bg <- meanF_data_functional %>%
#   filter(type == "exp") %>%
#   select(AA_var, RE, bg) %>%
#   group_by(RE) %>%
#   mutate(n = 1) %>%
#   pivot_wider(names_from = bg, values_from = n) %>%
#   mutate(both = AncSR1 + AncSR2 == 2) %>%
#   summarize(AncSR1 = sum(AncSR1, na.rm = T),
#             AncSR2 = sum(AncSR2, na.rm = T), 
#             both = sum(both, na.rm = T)) %>%
#   mutate(AncSR1 = AncSR1 - both,
#          AncSR2 = AncSR2 - both,
#          RE = factor(RE, levels = c("all", levels(REs[[1]])))) %>%
#   rbind(c("all", colSums(select(., 2:4)))) %>%
#   mutate(AncSR1 = as.numeric(AncSR1), AncSR2 = as.numeric(AncSR2),
#          both = as.numeric(both))
# 
# # compute p-value for overlap by bootstrap sampling variants in each background 
# # and computing amount of random overlap
# variants_bound_by_bg$p <- apply(select(variants_bound_by_bg, 2:4), 1,
#                                 function(x) {
#                                   overlaps <- numeric(length = 1000)
#                                   for(i in 1:1000) {
#                                     AncSR1_sample <- sample(160000, sum(x[c(1,3)]))
#                                     AncSR2_sample <- sample(160000, sum(x[2:3]))
#                                     overlaps[i] <- length(intersect(AncSR1_sample, AncSR2_sample))
#                                   }
#                                   p <- sum(overlaps >= x[3]) / 1000
#                                   p
#                                 })
# variants_bound_by_bg$padj <- p.adjust(variants_bound_by_bg$p, 
#                                       method = "bonferroni")
# 
# # plot fraction of protein variants per RE that are functional in the AncSR1,
# # AncSR2, or both backgrounds
# a <- variants_bound_by_bg %>%
#   mutate(AncSR1_total = AncSR1 + both) %>%
#   pivot_longer(2:4, names_to = "background") %>%
#   filter(background != "AncSR2") %>%
#   ggplot(aes(x = RE, y = value, 
#              fill = factor(background, levels = c("both", "AncSR1")))) +
#   geom_col(position = "stack", width = 0.9) +
#   scale_fill_manual(values = c(both = "deepskyblue", bg_color("AncSR1")),
#                     labels = c("AncSR1 and AncSR2", "AncSR1 only"),
#                     drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   geom_text(aes(y = AncSR1_total, label = ifelse(padj <= .05, "*", "")), 
#             vjust = 0, color = "black", size = 6) +
#   scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
#   labs(title = "Variants functional on AncSR1", x = "Response element", 
#        y = "Number of protein variants", fill = "Ancestral background") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         plot.title = element_text(size = 14),
#         legend.text = element_text(size =12),
#         legend.title = element_text(size = 14),
#         legend.position = c(0.8, 0.9),
#         plot.caption = element_text(hjust = 0)) +
#   guides(x = guide_axis(angle = 45))
# 
# # plot the distribution of fluorescence for protein variants that bind in 
# # both backgrounds
# fluorescence_both_backgrounds <- meanF_data_functional %>%
#   select(AA_var, RE, bg, avg_meanF) %>%
#   group_by(RE) %>%
#   pivot_wider(names_from = bg, values_from = avg_meanF) %>%
#   drop_na()
# fluorescence_bg_p <- fluorescence_both_backgrounds %>%
#   ungroup() %>%
#   summarize(p = wilcox.test(AncSR1, AncSR2, alternative = "less")$p.value)
# 
# b <- fluorescence_both_backgrounds %>%
#   pivot_longer(3:4, names_to = "background") %>%
#   ggplot(aes(x = factor(RE, levels = levels(REs[[1]])), y = value, 
#              fill = background)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(bg_color()), drop = FALSE) +
#   scale_x_discrete(drop = FALSE) +
#   labs(x = "Response element", y = "Fluorescence", 
#        fill = "Ancestral\nbackground") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.text = element_text(size = 14),
#         axis.line.x = element_line(color = "black",),
#         legend.position = "right",
#         plot.caption = element_text(hjust = 0)) +
#   guides(x = guide_axis(angle = 45))
# 
# c <- fluorescence_both_backgrounds %>%
#   pivot_longer(3:4, names_to = "background") %>%
#   ggplot(aes(x = background, y = value, fill = background)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(bg_color()), drop = FALSE) +
#   labs(title = "Variants functional on\nboth backgrounds", 
#        x = "Ancestral\nbackground", y = "Fluorescence") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         plot.title = element_text(size = 14),
#         legend.text = element_text(size = 14),
#         axis.line.x = element_line(color = "black",),
#         legend.position = "none",
#         plot.caption = element_text(hjust = 0)) +
#   guides(x = guide_axis(angle = 45)) +
#   geom_signif(comparisons = list(c("AncSR1", "AncSR2")), 
#               test = "wilcox.test",
#               test.args = list(alternative = "less"),
#               map_signif_level = TRUE)
# 
# a + plot_spacer() + c + plot_layout(widths = c(5, 0.5, 2))
# 
# # plot fluorescence in each background for variants that bind in both backgrounds
# d <- fluorescence_both_backgrounds %>%
#   ggplot(aes(x = AncSR1, y = AncSR2)) +
#   geom_point()
# d
```


### What is the distribution of fluorescence for variants that bind to each RE?

```{r fluorRE, purl = FALSE, eval = FALSE}
# fluorREplot <- meanF_data %>%
#   filter(functional) %>%
#   ggplot(aes(x = bg, y = avg_meanF, fill = bg)) +
#   # geom_violin(scale = "width") +
#   # stat_summary(geom = "point", fun = "median") +
#   geom_boxplot() +
#   facet_wrap(vars(RE), nrow = 2) +
#   scale_x_discrete(drop = FALSE, name = "") +
#   scale_fill_manual(values = bg_color(), drop = FALSE, 
#                     name = "Ancestral\nbackground") +
#   ylab("Fluorescence") +
#   theme_classic() +
#   theme(text = element_text(size = fontsize),
#         legend.text = element_text(size = fontsize),
#         strip.text = element_text(size = fontsize - 8),
#         strip.background = element_blank(),
#         axis.text.x = element_blank(),
#         axis.ticks.x = element_blank(),
#         axis.line.x = element_blank()) +
#   guides(x = guide_axis(angle = 45))
# fluorREplot
```




## How many protein variants bind promiscuously?

<!-- Let's now determine which protein variants bind promiscuously, *i.e.* are functional on multiple REs. Simply counting the number of REs on which each protein variant is classified as functional will overestimate the number of promiscuous variants due to multiple testing (each protein variant has been tested on 16 REs). To correct for this, for each possible set of $k$ REs where $k \in [1:16]$, we will compute a p-value for each protein variant as the probability that it is at least as fluorescent as the reference variant on all $k$ REs in the set. This is simply the product across all $k$ REs of the p-values computed for each RE:protein variant individually. We will again use an FDR threshold of 0.1 to classify variants as functional vs. nonfunctional on each set of REs. -->

```{r ppromiscuous, purl = TRUE, eval = FALSE}
# # Compute p-values for binding to multiple REs
# if(!file.exists(file.path(results_dir, "ppromiscuous.rda"))) {
#   # Create list to store p-values for the null hypothesis that a variant is at
#   # least as fluorescent as the reference variant on n RE variants, where 
#   # k in [1:16]. Each element is a dataframe listing the p-values for binding to
#   # k REs; each row is a protein:RE set combination, and there are k columns
#   # listing the REs in the set
#   ppromiscuous <- list()
#   
#   # The dataframe for k=1 simply lists the p-values for individual REs computed
#   # above, including only variant combinations with p>0 for computational 
#   # efficiency.
#   ppromiscuous[[1]] <- meanF_data %>% filter(p > 0) %>% select(bg:RE, p)
#   
#   # number of REs per protein variant with p > 0
#   npg0 <- ppromiscuous[[1]] %>% group_by(bg, AA_var) %>% count(name = "nRE")
#   
#   # Compute p-values for each k > 1
#   for(k in 2:16) {
#     print(paste("k =", k))
#     
#     # subset of data for which p > 0 for at least n REs per protein variant
#     datak <- ppromiscuous[[1]] %>% semi_join(filter(npg0, nRE >= k))
#     
#     # subset data by protein background (parallel)
#     cl <- makeCluster(2, "FORK", outfile = "")
#     registerDoParallel(cl)
#     
#     ppromiscuous[[k]] <- foreach(background = unique(as.character(datak$bg)), 
#                                  .combine = "rbind") %dopar% {
#       print(background)
#       databg <- filter(datak, bg == background)
#       out <- data.frame(matrix(nrow = 0, ncol = 0))
#       aas <- unique(as.character(databg$AA_var))
#       
#       # subset data by amino acid variant
#       for(aa in aas) {
#         print(aa)
#         dataaa <- filter(databg, AA_var == aa)
#         
#         # get all possible combinations of k REs
#         REcombos <- data.frame(t(combn(as.character(dataaa$RE), k)))
#         colnames(REcombos) <- sapply(1:k, function(x) paste0("RE", x))
#         
#         # compute p-val for each combination of REs
#         p <- apply(REcombos, 1, function(x)
#           dataaa %>% filter(RE %in% x) %>% pull(p) %>% prod())
#         
#         out <- rbind(out, data.frame(bg = background, AA_var = aa, REcombos, p))
#       }
#     }
#     stopCluster(cl)
#   }
#   
#   save(ppromiscuous, file = file.path(results_dir, "ppromiscuous.rda"))
# } else load(file.path(results_dir, "ppromiscuous.rda"))
```

```{r, purl = FALSE, eval = FALSE}
# if(!file.exists(file.path(results_dir, "multiple_REs_bound_data.rda"))) {
#   multiple_REs_bound_data <- list(AncSR1 = list(), AncSR2 = list())
#   multiple_REs_bound_data[["AncSR1"]][[1]] <- meanF_data_functional %>% 
#     filter(bg == "AncSR1") %>% 
#     mutate(p = pfunctional, padj = padjfunctional, RE1 = RE) %>%
#     select(AA_var, RE1, p, padj)
#   multiple_REs_bound_data[["AncSR2"]][[1]] <- meanF_data_functional %>% 
#     filter(bg == "AncSR2") %>% 
#     mutate(p = pfunctional, padj = padjfunctional, RE1 = RE) %>%
#     select(AA_var, RE1, p, padj)
#   
#   # initialize data frames
#   for(background in c("AncSR1", "AncSR2")) {
#     for(i in 2:16) {
#       df <- data.frame(AA_var = NA)
#       df[sapply(1:i, function(x) paste0("RE", x))] <- NA
#       df$p <- NA
#       multiple_REs_bound_data[[background]][[i]] <- df
#     }
#   }
#   
#   for(background in c("AncSR1", "AncSR2")) {
#     AA_vars <- meanF_data_active %>%
#         filter(bg == background) %>% pull("AA_var") %>% 
#         unique() %>% as.character() %>% sort()
#     
#     for(aa in AA_vars) {
#       print(aa)
#       aa_df <- meanF_data_active %>% 
#           filter(AA_var == aa, bg == background) %>%
#           select(RE, meanF_REP1:meanF_REP4, pfunctional)
#       i <- 2
#       while(i <= nrow(aa_df)) {
#         # compute all possible sets of i REs for variant aa
#         RE_combs <- combn(as.character(aa_df$RE), i)
#         
#         # compute p-value of aa being worse than AncSR2-WT:SRE1 on any of the
#         # set of REs
#         p <- apply(RE_combs, 2, function(x) {
#           df2 <- aa_df %>% filter(RE %in% x)
#           prod(df2$pfunctional)
#         })
#         
#         new_df <- data.frame(AA_var = rep(aa, ncol(RE_combs)))
#         new_df[sapply(1:i, function(x) paste0("RE", x))] <- t(RE_combs)
#         new_df$p <- p
#         multiple_REs_bound_data[[background]][[i]] <- 
#           multiple_REs_bound_data[[background]][[i]] %>%
#           rbind(new_df)
#         
#         i <- i + 1
#       }
#     }
#   }
#   
#   # merge data for AncSR1 & AncSR2
#   multiple_REs_bound_data <- lapply(1:16, function(x) 
#     rbind(multiple_REs_bound_data[[1]][[x]] %>% 
#             slice(-1) %>% mutate(bg = "AncSR1"), 
#           multiple_REs_bound_data[[2]][[x]] %>% 
#             slice(-1) %>% mutate(bg = "AncSR2")))
#   
#   # compute adjusted p-values
#   multiple_REs_bound_data <- lapply(multiple_REs_bound_data, function(x)
#     mutate(x, padj = p.adjust(p, "fdr")))
#   
#   save(multiple_REs_bound_data, 
#        file = file.path(results_dir, "multiple_REs_bound_data.rda"))
# } else load(file = file.path(results_dir, "multiple_REs_bound_data.rda"))
# 
# # TODO: check what's up with AncSR1 AAKM
```


## Specificity vs. Promiscuity

Let's now identify how many protein variants bind specifically vs. promiscuously. Protein variants are defined as "specific" if they are functional on only one RE variant, and "promiscuous" if they bind to multiple RE variants.

```{r nspecific, purl = FALSE, fig.height = 5, fig.width = 6}
# Count the number of REs on which each protein variant is functional.
meanF_data_specificity <- meanF_data %>%
  pivot_wider(id_cols = bg:AA_var, names_from = RE, 
              values_from = c(avg_meanF, functional), 
              names_sep = "_") %>%
  mutate(nfxnal = rowSums(select(., 19:34)))

# Print the number of REs bound vs. number of protein variants
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(nfxnal = factor(nfxnal, levels = 1:16)) %>%
  group_by(bg, nfxnal) %>%
  dplyr::rename(nREs = nfxnal) %>%
  count(name = "nproteinvars") %>%
  group_by(bg) %>%
  mutate(fracfxnal = round(nproteinvars / sum(nproteinvars), 3)) %>%
  pivot_wider(names_from = bg, values_from = nproteinvars:fracfxnal, 
              values_fill = 0) %>%
  knitr::kable(caption = "Number of protein variants bound to n REs")

# Plot the number of REs on which each protein variant is functional
nREbarplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  ggplot(aes(x = nfxnal, fill = bg)) +
  geom_bar() +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_x_continuous(breaks = 1:16) +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  xlab("Number of REs bound") +
  ylab("Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9))
nREbarplot
```


How many protein variants bind specifically to each RE?

```{r nREsbound, purl = FALSE}
# count the number of protein that bind specifically to each RE in each 
# background
nspecificRE <- meanF_data_specificity %>%
  filter(nfxnal == 1) %>%
  select(-c(3:18, nfxnal)) %>%
  pivot_longer(3:18, names_to = "RE", values_to = "fxnal", 
               names_prefix = "functional_") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  filter(fxnal) %>%
  group_by(bg, RE) %>%
  count(name = "nproteinvars") %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0))

kable(nspecificRE %>% 
        group_by(bg) %>%
        mutate(fracproteinvars = round(nproteinvars / sum(nproteinvars), 3)) %>%
        pivot_wider(names_from = bg, 
                    values_from = nproteinvars:fracproteinvars),
      caption = "Number of protein variants bound specifically per RE")
```

Create barplot.

```{r nspecificRE, purl = FALSE, fig.height = 6, fig.width = 7}
# plot number of protein variants bound specifically on each RE/background as a
# bar plot
nspecificbarplot <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  ggplot(aes(x = RE, y = nproteinvars, fill = bg)) +
  geom_col() +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  ylab("Number of protein variants bound specifically") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = c(0.9, 0.9)) +
  guides(x = guide_axis(angle = 45))
nspecificbarplot
```

Barplot with total bound and specifically bound variants per RE.

```{r nboundspecificRE, purl = FALSE, fig.height = 6, fig.width = 7}
nspecificboundbarplot <- meanF_data_specificity %>%
  ungroup() %>%
  filter(nfxnal > 0) %>%
  mutate(phenotype = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, `functional_ERE (GT)`:functional_TT, phenotype) %>%
  pivot_longer(`functional_ERE (GT)`:functional_TT, names_to = "RE",
               values_to = "bound", names_prefix = "functional_") %>%
  filter(bound) %>%
  # left_join(select(meanF_data, bg, RE, AA_var, type)) %>%
  # filter(type == "binned") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  ggplot(aes(x = RE, fill = phenotype)) +
  geom_bar(position = "stack") +
  facet_grid(rows = vars(bg), scales = "free_y") +
  theme_classic() +
  guides(x = guide_axis(angle = 45))
nspecificboundbarplot
  
  
# split plots by background
nspecificboundbarplotAncSR1 <- meanF_data_specificity %>%
  ungroup() %>%
  filter(nfxnal > 0, bg == "AncSR1") %>%
  mutate(phenotype = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, `functional_ERE (GT)`:functional_TT, phenotype) %>%
  pivot_longer(`functional_ERE (GT)`:functional_TT, names_to = "RE",
               values_to = "bound", names_prefix = "functional_") %>%
  filter(bound) %>%
  # left_join(select(meanF_data, bg, RE, AA_var, type)) %>%
  # filter(type == "binned") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  ggplot(aes(x = RE, fill = phenotype)) +
  geom_bar(position = "stack") +
  scale_x_discrete(drop = FALSE) +
  labs(title = "AncSR1 functional variants", y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize)) +
  guides(x = guide_axis(angle = 45))
nspecificboundbarplotAncSR1

nspecificboundbarplotAncSR2 <- meanF_data_specificity %>%
  ungroup() %>%
  filter(nfxnal > 0, bg == "AncSR2") %>%
  mutate(phenotype = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, `functional_ERE (GT)`:functional_TT, phenotype) %>%
  pivot_longer(`functional_ERE (GT)`:functional_TT, names_to = "RE",
               values_to = "bound", names_prefix = "functional_") %>%
  filter(bound) %>%
  # left_join(select(meanF_data, bg, RE, AA_var, type)) %>%
  # filter(type == "binned") %>%
  mutate(RE = factor(RE, levels = levels(REs[[1]]))) %>%
  ggplot(aes(x = RE, fill = phenotype)) +
  geom_bar(position = "stack") +
  scale_x_discrete(drop = FALSE) +
  labs(title = "AncSR2 functional variants", y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize)) +
  guides(x = guide_axis(angle = 45))
nspecificboundbarplotAncSR2
```


Does the number of protein variants bound specifically per RE correlate with the total number of protein variants bound per RE?

```{r ntotalspecificREcor, purl = FALSE, fig.height = 5.5, fig.width = 8}
# plot number of protein variants bound specifically vs. number bound total per
# RE/bg
nboundspecificvtotalplot <- nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(nboundRE) %>%
  rename(ntotal = n) %>%
  ggplot(aes(x = ntotal, y = nspecific)) +
  geom_smooth(method = "lm", color = "black") +
  geom_point(aes(color = bg)) +
  geom_text_repel(aes(label = RE), box.padding = 0.15) +
  facet_wrap(vars(bg), ncol = 2, scales = "free") +
  scale_color_manual(values = bg_color(), name = "Ancestral\nbackground") +
  ylim(0, NA) +
  labs(x = "Number of protein variants bound total",
       y = "Number of protein variants bound specifically") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "right")
nboundspecificvtotalplot

# print Pearson's r^2 between total and specific variants bound per RE in each
# background
nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(nboundRE) %>%
  rename(ntotal = n) %>%
  group_by(bg) %>%
  summarize("r" = cor(nspecific, ntotal)) %>%
  mutate(r2 = r^2) %>%
  kable(caption = "r^2 n total vs. specific protein variants bound per RE")

# plot number protein variants bound and bound specifically per RE
nboundspecifictotalbarplot <- nspecificRE %>%
  rename(nspecific = nproteinvars) %>%
  full_join(meanF_data %>%
              filter(functional) %>%
              group_by(bg, RE) %>%
              summarize(ntotal = n())) %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nspecific = 0, ntotal = 0)) %>%
  mutate(npromiscuous = ntotal - nspecific) %>%
  pivot_longer(c(nspecific, npromiscuous), names_to = "specific", 
               names_prefix = "n", values_to = "n") %>%
  ggplot(aes(x = RE, y = n, fill = bg, alpha = specific)) +
  geom_col(position = "fill") +
  facet_wrap(vars(bg), nrow = 2, scales = "free_y") +
  scale_fill_manual(values = bg_color(), drop = FALSE, 
                    name = "Ancestral\nbackground") +
  scale_alpha_manual(values = c("specific" = 1, "promiscuous" = 0.5)) +
  ylab("Number of protein variants bound") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        legend.text = element_text(size = fontsize),
        strip.background = element_blank(),
        strip.text = element_blank(),
        legend.position = "right") +
  guides(x = guide_axis(angle = 45))
nboundspecifictotalbarplot
```

For those protein variants that bind to multiple REs (promiscuous), which RE combinations do they bind to? Plot a heatmap of the number of protein variants that bind to each pair of REs. 

```{r promiscuousheatmaps, purl = FALSE, fig.height = 6, fig.width = 8}
npromiscuousREpairs <- map_dfr(combn(colnames(meanF_data_specificity)[19:34], 2,
                                     simplify = FALSE),
                               ~ meanF_data_specificity %>%
                                 filter(nfxnal >= 2) %>%
                                 select(c(bg, all_of(.x))) %>%
                                 mutate(n = rowSums(select(., -bg))) %>%
                                 group_by(bg) %>%
                                 summarize(pairs = paste(sub("functional_", "", .x), 
                                                         collapse = "_"),
                                           n = sum(n == 2))) %>%
  separate(pairs, c("RE1", "RE2"), sep = "_") %>%
  mutate(RE1 = factor(RE1, levels = levels(REs[[1]])),
         RE2 = factor(RE2, levels = levels(REs[[1]])))

promiscuousheatmapAncSR1 <- npromiscuousREpairs %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = RE1, y = RE2, fill = n)) +
  geom_tile() +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR1", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

# promiscuousheatmapAncSR1 <- npromiscuousREpairs %>%
#   filter(bg == "AncSR1") %>%
#   select(-bg) %>%
#   pivot_wider(names_from = "RE2", values_from = "n") %>%
#   column_to_rownames("RE1") %>%
#   apply(1:2, function(x) x / (meanF_data_specificity %>% 
#                                 filter(nfxnal >= 2, bg == "AncSR1") %>%
#                                 nrow())) %>%
#   heatmaply(dendrogram = "none")

promiscuousheatmapAncSR2 <- npromiscuousREpairs %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(x = RE1, y = RE2, fill = n)) +
  geom_tile() +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR2", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousheatmapAncSR1 + promiscuousheatmapAncSR2
```

Heatmaps v2

```{r promiscuousheatmaps2, purl = FALSE, fig.height = 5, fig.width = 7}
# fill scale: fraction of promiscuous variants
promiscuousheatmapbothbg <- npromiscuousREpairs %>%
  mutate(frac = ifelse(bg == "AncSR1", 
                       n / (meanF_data_specificity %>% 
                              filter(nfxnal >= 2, bg == "AncSR1") %>%
                              nrow()),
                       n / (meanF_data_specificity %>% 
                              filter(nfxnal >= 2, bg == "AncSR2") %>%
                              nrow()))) %>%
  ggplot(aes(fill = frac)) +
  geom_tile(data = . %>% filter(bg == "AncSR1"), aes(x = RE1, y = RE2)) +
  geom_tile(data = . %>% filter(bg == "AncSR2"), aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[1]])) +
  scale_y_discrete(limits = levels(REs[[1]])) +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "", y = "", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45))

# fill scale: fraction of specific variants
specificheatmapAncSR1 <- nspecificRE %>%
  ungroup() %>%
  filter(bg == "AncSR1") %>%
  select(-bg) %>%
  complete(RE, fill = list(nproteinvars = 0)) %>%
  mutate(frac = nproteinvars / (meanF_data_specificity %>%
                                  filter(nfxnal == 1, bg == "AncSR1") %>%
                                  nrow())) %>%
  ggplot(aes(x = RE, y = "Specific", fill = frac)) +
  geom_tile() +
  scale_x_discrete(limits = levels(REs[[1]]), position = "top") +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "AncSR1 background", y = "", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.title.x.top = element_text(size = fontsize),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())

specificheatmapAncSR2 <- nspecificRE %>%
  ungroup() %>%
  filter(bg == "AncSR2") %>%
  select(-bg) %>%
  complete(RE, fill = list(nproteinvars = 0)) %>%
  mutate(frac = nproteinvars / (meanF_data_specificity %>%
                                  filter(nfxnal == 1, bg == "AncSR2") %>%
                                  nrow())) %>%
  ggplot(aes(x = "Specific", y = RE, fill = frac)) +
  geom_tile() +
  scale_y_discrete(limits = levels(REs[[1]]), position = "right") +
  scale_fill_viridis(limits = c(0, 0.48)) +
  labs(x = "", y = "AncSR2 background", fill = "Fraction of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.title.y.right = element_text(size = fontsize),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank()) +
  guides(x = guide_axis(angle = 45))

(specificheatmapAncSR1 + theme(legend.position = "none")) +
  plot_spacer() +
  (promiscuousheatmapbothbg + theme(legend.position = "none")) +
  (specificheatmapAncSR2 + theme(legend.position = "right")) +
  plot_layout(ncol = 2, byrow = TRUE, widths = c(16, 1), heights = c(1, 16))
```

Heatmaps v3

```{r promiscuousheatmaps3, purl = FALSE, fig.height = 6, fig.width = 8}
promiscuousspecificheatmapAncSR1 <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(fill = n)) +
  geom_tile(aes(x = RE1, y = RE2)) +
  geom_tile(aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[1]])) +
  scale_y_discrete(limits = levels(REs[[1]])) +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR1", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousspecificheatmapAncSR2 <- nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR2") %>%
  ggplot(aes(fill = n)) +
  geom_tile(aes(x = RE1, y = RE2)) +
  geom_tile(aes(x = RE2, y = RE1)) +
  scale_x_discrete(limits = levels(REs[[1]])) +
  scale_y_discrete(limits = levels(REs[[1]])) +
  scale_fill_viridis() +
  labs(x = "", y = "", title = "AncSR2", fill = "Number of\nprotein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize - 2),
        legend.position = "bottom") +
  guides(x = guide_axis(angle = 45),
         fill = guide_colorbar(title.position = "top",
                               title.theme = element_text(size = fontsize - 2),
                               label.theme = element_text(angle = 45),
                               label.hjust = 1))

promiscuousspecificheatmapAncSR1 + promiscuousspecificheatmapAncSR2
```

Clustered heatmaps

```{r clusteredheatmap, purl = FALSE}
# AncSR1 (removed RE variants with nothing bound)
nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR1") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", 
            breaks = 0:max(.))

# AncSR2 (removed RE variants with nothing bound)
nspecificRE %>%
  ungroup() %>%
  complete(bg, RE, fill = list(nproteinvars = 0)) %>%
  rename(RE1 = RE, n = nproteinvars) %>%
  mutate(RE2 = RE1) %>%
  rbind(npromiscuousREpairs) %>%
  filter(bg == "AncSR2") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both",
            breaks = 0:max(.))
```

Clustered heatmaps no specific

```{r clusteredheatmapnospecific, purl = FALSE}
# AncSR1 (removed RE variants with nothing bound)
npromiscuousREpairs %>%
  filter(bg == "AncSR1") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  arrange(RE2, RE1) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n, values_fill = 0) %>%
  arrange(RE1) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", symm = TRUE,
            breaks = 0:max(.), margins = c(6, 6), density.info = "none", 
            key.title = "", key.xlab = "Number of protein variants",
            main = "AncSR1 background")

# AncSR2 (removed RE variants with nothing bound)
npromiscuousREpairs %>%
  filter(bg == "AncSR2") %>%
  rbind(rename(., RE1 = RE2, RE2 = RE1) %>% filter(RE1 != RE2)) %>%
  arrange(RE2, RE1) %>%
  filter(!RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE,
         !RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE) %>%
  pivot_wider(names_from = RE2, values_from = n, values_fill = 0) %>%
  arrange(RE1) %>%
  column_to_rownames("RE1") %>%
  select(-bg) %>%
  as.matrix() %>%
  heatmap.2(col = viridis, trace = "none", dendrogram = "both", symm = TRUE,
            breaks = 0:max(.), margins = c(6, 6), density.info = "none", 
            key.title = "", key.xlab = "Number of protein variants",
            main = "AncSR2 background")
```



Are there RE sequence determinants of promiscuity?

```{r promiscuitydeterminantsRE, purl = FALSE, fig.height = 5, fig.width = 7}
# Can promiscuity be explained by modeling the probability of binding each RE
# variant as independent? First just look at the pairwise co-binding 
# probabilities (the probability that two REs are co-bound by the same protein
# variant)
REpairs <- as.data.frame(t(combn(levels(REs[[1]]), 2)))
colnames(REpairs) <- c("RE1", "RE2")
REpairs <- REpairs %>%
  left_join(nboundRE, by = c("RE1" = "RE")) %>%
  left_join(nboundRE, by = c("bg", "RE2" = "RE"), suffix = c("1", "2")) %>%
  left_join(meanF_data_specificity %>% 
              filter(nfxnal > 0) %>% 
              count(bg, name = "ntotal"), 
            by = "bg") %>%
  left_join(npromiscuousREpairs) %>%
  rename(n12 = n) %>%
  mutate(p1 = n1 / ntotal, p2 = n2 / ntotal, p12true = n12 / ntotal, 
         p12pred = p1 * p2) %>%
  filter(!(bg == "AncSR1" & RE1 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE),
         !(bg == "AncSR1" & RE2 %in% filter(nboundRE, bg == "AncSR1", n == 0)$RE),
         !(bg == "AncSR2" & RE1 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE),
         !(bg == "AncSR2" & RE2 %in% filter(nboundRE, bg == "AncSR2", n == 0)$RE))
coboundpairstruevpredplotAncSR1 <- REpairs %>%
  filter(bg == "AncSR1") %>%
  unite(RE1, RE2, col = "REs") %>%
  select(REs, p12true, p12pred) %>%
  ggplot(aes(x = p12pred, y = p12true)) +
  geom_point(color = bg_color()[1]) +
  # geom_smooth(method = "lm", color = "red") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(y = "true co-binding frequency", 
       x = "predicted independent co-binding frequency",
       title = "AncSR1") +
  theme_classic()
coboundpairstruevpredplotAncSR2 <- REpairs %>%
  filter(bg == "AncSR2") %>%
  unite(RE1, RE2, col = "REs") %>%
  select(REs, p12true, p12pred) %>%
  ggplot(aes(x = p12pred, y = p12true)) +
  geom_point(color = bg_color()[2]) +
  # geom_smooth(method = "lm", color = "red") +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(y = "true co-binding frequency", 
       x = "predicted independent co-binding frequency",
       title = "AncSR2") +
  theme_classic()
coboundpairstruevpredplotAncSR1 + coboundpairstruevpredplotAncSR2

# How much more likely is an RE variant to be cobound with another RE variant 
# that has the same nucleotide at position 1 or 2 compared?
# Use a likelihood ratio test to test for effects of matching nucleotides at
# site 1 or 2 in the RE compared to a null model where cobinding frequencies are
# predicted from the independent binding expectation alone.
REpairsmatch <- REpairs %>%
  mutate(RE1 = gsub(".+\\(|\\)", "", RE1), RE2 = gsub(".+\\(|\\)", "", RE2)) %>%
  separate_wider_position(RE1, widths = c("RE1.1" = 1, "RE1.2" = 1)) %>%
  separate_wider_position(RE2, widths = c("RE2.1" = 1, "RE2.2" = 1)) %>%
  mutate(A1 = RE1.1 == "A" & RE2.1 == "A",
         C1 = RE1.1 == "C" & RE2.1 == "C",
         G1 = RE1.1 == "G" & RE2.1 == "G",
         T1 = RE1.1 == "T" & RE2.1 == "T",
         A2 = RE1.2 == "A" & RE2.2 == "A",
         C2 = RE1.2 == "C" & RE2.2 == "C",
         G2 = RE1.2 == "G" & RE2.2 == "G",
         T2 = RE1.2 == "T" & RE2.2 == "T")
  # mutate(match = map2_int(RE1, RE2, 
  #                         ~ str_split_fixed(c(.x, .y), "", 2) %>%
  #                           apply(2, function(x) x[1] == x[2]) %>%
  #                           {if(sum(.) == 1) which(.) else 0}))

REsiteeffect <- as.data.frame(matrix(nrow = 0, ncol = 4))
colnames(REsiteeffect) <- c("bg", "effect", "beta", "p")
for(b in c("AncSR1", "AncSR2")) {
  lmH0 <- lm(p12true ~ p12pred, REpairsmatch %>% filter(bg == b))
  print(b)
  print(summary(lmH0))
  for(position in 1:2) {
    for(nt in c("A", "C", "G", "T")) {
      datasub <- REpairsmatch %>% filter(bg == b) %>%
      select(p12true, p12pred, paste0(nt, position)) %>%
        rename(match = paste0(nt, position))
      lmH1 <- lm(p12true ~ p12pred + match, datasub)
      LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
      pval <- pchisq(LRS, df = 1, lower.tail = FALSE)
      
      REsiteeffect <- REsiteeffect %>% 
      rbind(data.frame(bg = b, effect = paste0(nt, position), 
                       beta = coef(lmH1)[3], p = pval), 
            make.row.names = FALSE)
    }
  }
}
print(REsiteeffect)

REeffect <- as.data.frame(matrix(nrow = 0, ncol = 5))
colnames(REeffect) <- c("bg", "effect", "beta", "p", "adjr2")
for(b in c("AncSR1", "AncSR2")) {
  lmH0 <- lm(p12true ~ p12pred, REpairs %>% filter(bg == b))
  print(b)
  print(summary(lmH0))
  for(RE in levels(REs[[1]])) {
    datasub <- REpairs %>% filter(bg == b) %>%
    select(p12true, p12pred, RE1, RE2) %>%
      mutate(match = RE1 == RE | RE2 == RE)
    lmH1 <- lm(p12true ~ p12pred + match, datasub)
    LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
    pval <- pchisq(LRS, df = 1, lower.tail = FALSE)
    
    REeffect <- REeffect %>% 
    rbind(data.frame(bg = b, effect = RE, 
                     beta = coef(lmH1)[3], p = pval, 
                     adjr2 = summary(lmH1)$adj.r.squared), 
          make.row.names = FALSE)
  }
}
REeffect <- REeffect %>% drop_na()
REeffect$padj <- p.adjust(REeffect$p, method = "fdr")
print(REeffect)

# AncSR2 fit with SRE1 and SRE2 variables
datasub <- REpairs %>% filter(bg == "AncSR2") %>% 
  mutate(SRE1 = RE1 == "SRE1 (AA)" | RE2 == "SRE1 (AA)", 
         SRE2 = RE1 == "SRE2 (GA)" | RE2 == "SRE2 (GA)")
# test against SRE1-only model
lmH0 <- lm(p12true ~ p12pred + SRE1, datasub)
lmH1 <- lm(p12true ~ p12pred + SRE1 + SRE2, datasub)
LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
pchisq(LRS, df = 1, lower.tail = FALSE)
# test against SRE2-only model
lmH0 <- lm(p12true ~ p12pred + SRE2, datasub)
LRS <- -2 * (as.numeric(logLik(lmH0)) - as.numeric(logLik(lmH1)))
pchisq(LRS, df = 1, lower.tail = FALSE)
summary(lmH1)$adj.r.squared


# Plot fits with additional SRE1 and SRE2 RE explanatory variables
coboundpairstruevpredplotAncSR2SRE <- data.frame(pred = lmH1$fitted.values, 
                                                 obs = lmH1$model$p12true) %>%
  ggplot(aes(x = pred, y = obs)) +
  geom_point(color = bg_color()[2]) +
  geom_smooth(method = "lm", color = "red") +
  labs(y = "true co-binding frequency", 
       x = "predicted independent co-binding frequency",
       title = "AncSR2") +
  theme_classic()
(coboundpairstruevpredplotAncSR2 +
    labs(title = "AncSR2 independent frequency\npredictions")) + 
  (coboundpairstruevpredplotAncSR2SRE +
    labs(title = "AncSR2 independent frequency\npredictions + SRE1 + SRE2"))
```


How do protein variants switch between specific and promiscuous categories between the AncSR1 and AncSR2 backgrounds? Do they switch specificity?

```{r bgphenotypeswitch, purl = FALSE, fig.height = 6, fig.width = 8}
# Of protein variants that are functional in either ancestral background, how do
# their phenotypes (specific, promiscuous, or nonfunctional) differ between the
# backgrounds?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in specificity/promsicuity phenotype")

specificpromiscuousswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if((.x == "specific" & .y == "promiscuous") |
                                 .x == "nonfunctional") "gained binding"
                             else if(.x == .y) "maintained binding"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c("specific", "promiscuous", 
                                            "nonfunctional")),
         AncSR2 = factor(AncSR2, levels = c("specific", "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("gained binding",
                                            "maintained binding",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
specificpromiscuousswitchplot

# Of protein variants that are specific in the AncSR1 background, do they change
# specificity or maintain the same specificity in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR1 == "specific") %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR1specificswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR1 %in% REs[[1]]) %>%
  replace_na(list(AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"
                             else if(.y == "promiscuous") "gained promiscuity"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = levels(REs[[1]])),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained promiscuity",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1specificswitchplot


# Of protein variants that are functional in the AncSR1 background, what is
# their phenotype in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR1 %in% c("specific", "promiscuous")) %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR1functionalswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR1 %in% c(levels(REs[[1]]), "promiscuous")) %>%
  replace_na(list(AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.y == "promiscuous") "gained/maintained promiscuity"
                             else if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"
                             else "lost binding"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c(levels(REs[[1]]), "promiscuous")),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous", 
                                            "nonfunctional")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained/maintained promiscuity",
                                            "lost binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1functionalswitchplot


# Of protein variants that are functional in the AncSR2 background, what is
# their phenotype in the AncSR2 background?
meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specific = ifelse(nfxnal == 1, "specific", "promiscuous")) %>%
  select(bg, AA_var, specific) %>%
  pivot_wider(names_from = bg, values_from = specific) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  ungroup() %>%
  filter(AncSR2 %in% c("specific", "promiscuous")) %>%
  mutate(frac = n / sum(n)) %>%
  kable(caption = "Change in phenotype for AncSR1 specific variants")

AncSR2functionalswitchplot <- meanF_data_specificity %>%
  filter(nfxnal > 0) %>%
  mutate(specificity = apply(select(., `functional_ERE (GT)`:functional_TT), 
                             1, which)) %>%
  mutate(specificity = sapply(specificity, function(x) 
    ifelse(length(x) == 1, levels(REs[[1]])[x], "promiscuous"))) %>%
  select(bg, AA_var, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  filter(AncSR2 %in% c(levels(REs[[1]]), "promiscuous")) %>%
  replace_na(list(AncSR1 = "nonfunctional")) %>%
  count(AncSR1, AncSR2) %>%
  mutate(change = map2_chr(AncSR1, AncSR2,
                           ~ {if(.x == "nonfunctional") "gained binding"
                             else if(.y == "promiscuous") "gained/maintained promiscuity"
                             else if(.x == .y) "maintained specificity"
                             else if(.y %in% REs[[1]]) "switched specificity"})) %>%
  mutate(AncSR1 = factor(AncSR1, levels = c(levels(REs[[1]]), "promiscuous",
                                            "nonfunctional")),
         AncSR2 = factor(AncSR2, levels = c(levels(REs[[1]]), "promiscuous")),
         change = factor(change, levels = c("maintained specificity", 
                                            "switched specificity",
                                            "gained/maintained promiscuity",
                                            "gained binding"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = change)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  # guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR2functionalswitchplot


# of protein:RE variants that were functional in the AncSR1 background, did they
# stay functional or become nonfunctional in the AncSR2 background?
meanF_data_fxnal %>%
  filter(functional_AncSR1) %>%
  count(RE, functional_AncSR2) %>%
  mutate(RE = droplevels(RE)) %>%
  complete(RE, functional_AncSR2, fill = list(n = 0)) %>%
  group_by(RE) %>%
  mutate(ntotal = sum(n), frac = n / ntotal) %>%
  filter(!functional_AncSR2)

AncSR1functionalcomplexswitchplot <- meanF_data_fxnal %>%
  filter(functional_AncSR1) %>%
  count(functional_AncSR1, functional_AncSR2, RE) %>%
  mutate(AncSR1 = factor(ifelse(functional_AncSR1, "functional", "nonfunctional"),
                         levels = c("functional", "nonfunctional")),
         AncSR2 = factor(ifelse(functional_AncSR2, "functional", "nonfunctional"),
                         levels = c("functional", "nonfunctional"))) %>%
  ggplot(aes(y = n, axis1 = AncSR1, axis2 = AncSR2)) +
  geom_alluvium(aes(fill = RE)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  labs(y = "Number of protein variants") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())
AncSR1functionalcomplexswitchplot
```


What are the amino acid sequence determinants of binding, specificity, and promiscuity?

```{r logoplots, purl = FALSE, fig.height = 6, fig.width = 7, eval = F}
allbindersbybglogoplot <- list(AncSR1 = meanF_data %>% 
                             filter(functional, bg == "AncSR1") %>% 
                             pull(AA_var) %>%
                             as.character() %>%
                             unique(),
                           AncSR2 = meanF_data %>%
                             filter(functional, bg == "AncSR2") %>%
                             pull(AA_var) %>%
                             as.character() %>%
                             unique()) %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize)) +
  labs(x = "RH position", title = "All binders")
allbindersbybglogoplot

allbindersbybgRElogoplot <- list(AncSR1 = meanF_data %>%
                                   filter(functional, bg == "AncSR1") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)},
                                 AncSR2 = meanF_data %>%
                                   filter(functional, bg == "AncSR2") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)}) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 4) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders")
allbindersbybgRElogoplot

# separate plots for each background
allbindersbybgRElogoplotAncSR1 <- meanF_data %>%
                                   filter(functional, bg == "AncSR1") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)} %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 2) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders AncSR1")
allbindersbybgRElogoplotAncSR1

allbindersbybgRElogoplotAncSR2 <- meanF_data %>%
                                   filter(functional, bg == "AncSR2") %>%
                                   {sapply(levels(REs[[1]]), function(x)
                                     filter(., RE == x) %>% pull(AA_var) %>%
                                       as.character(), USE.NAMES = TRUE)} %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 2) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "All binders AncSR2")
allbindersbybgRElogoplotAncSR2


specificbinderslogoplot <- list(AncSR1 = meanF_data_specificity %>% 
                                  filter(nfxnal == 1, bg == "AncSR1") %>% 
                                  mutate(specificity = 
                                           apply(select(., `functional_ERE (GT)`:functional_TT), 
                                                 1, function(x) 
                                                   as.character(REs[[1]][which(x)]))) %>%
                                  {sapply(levels(REs[[1]]), function(x)
                                    filter(., specificity == x) %>% 
                                      pull(AA_var) %>% as.character(),
                                    USE.NAMES = TRUE)},
                                AncSR2 = meanF_data_specificity %>% 
                                  filter(nfxnal == 1, bg == "AncSR2") %>% 
                                  mutate(specificity = 
                                           apply(select(., `functional_ERE (GT)`:functional_TT), 
                                                 1, function(x) 
                                                   as.character(REs[[1]][which(x)]))) %>%
                                  {sapply(levels(REs[[1]]), function(x)
                                    filter(., specificity == x) %>% 
                                      pull(AA_var) %>% as.character(),
                                    USE.NAMES = TRUE)}) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  discard(~ length(.x) == 0) %>%
  ggseqlogo(method = "probability", nrow = 4) +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "Specific binders")
specificbinderslogoplot

promiscuousbinderslogoplot <- list(AncSR1 = meanF_data_specificity %>% 
                                  filter(nfxnal > 1, bg == "AncSR1") %>% 
                                  pull(AA_var) %>% unique() %>% as.character(),
                                AncSR2 = meanF_data_specificity %>% 
                                  filter(nfxnal > 1, bg == "AncSR2") %>% 
                                  pull(AA_var) %>% unique() %>% as.character()) %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize)) +
  labs(x = "RH position", title = "Promiscuous binders")
promiscuousbinderslogoplot

promiscuouspairslogoplot <- list(AncSR1 = map2(c("ERE (GT)", "SRE1 (AA)", "SRE1 (AA)"),
                                               c("AT", "AT", "CA"),
                                               ~ meanF_data_specificity %>%
                                                 filter(bg == "AncSR1",
                                                        !!sym(paste0("functional_", .x)),
                                                        !!sym(paste0("functional_", .y))) %>%
                                                 pull(AA_var) %>% as.character()) %>%
                                   set_names(c("ERE (GT), AT", "SRE1 (AA), AT", "SRE1 (AA), CA")),
                                 AncSR2 = map2(c("SRE1 (AA)", "SRE1 (AA)", "SRE1 (AA)", "AT", "CA"),
                                               c("AT", "CA", "TA", "TT", "TA"),
                                               ~ meanF_data_specificity %>%
                                                 filter(bg == "AncSR2",
                                                        !!sym(paste0("functional_", .x)),
                                                        !!sym(paste0("functional_", .y))) %>%
                                                 pull(AA_var) %>% as.character()) %>%
                                   set_names(c("SRE1 (AA), AT", "SRE1 (AA), CA", "SRE1 (AA), TA", 
                                               "AT, TT", "CA, TA"))) %>%
  list_flatten(name_spec = "{outer} {inner}") %>%
  ggseqlogo(method = "probability") +
  theme(text = element_text(size = fontsize - 4)) +
  labs(x = "RH position", title = "Promiscuous binders")
promiscuouspairslogoplot
```


``` {r, purl = FALSE, eval = FALSE}
# plot the number of REs each RH variant is active on
a1 <- multiple_REs_variants %>%
  mutate(specific = factor(ifelse(nREs == 1, "specific", "promiscuous"),
                           levels = c("specific", "promiscuous"))) %>%
  group_by(bg, specific) %>%
  count(name = "nvars") %>%
  ggplot(aes(x = as.factor(specific), y = nvars, fill = bg)) +
  geom_col(width=0.9) +
  geom_text(aes(label=nvars), vjust=-0.5, color="black", size=4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_fill_manual(values=bg_color()) +
  labs(title = "", x = "", 
       y = "Number of protein variants",
       fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.position = "none",
        strip.background = element_blank(),
        strip.text.y = element_blank()) +
  guides(x = guide_axis(angle = 45))

a2 <- multiple_REs_variants %>%
  group_by(bg, nREs) %>% 
  count(name = "nvars") %>%
  ggplot(aes(x = as.factor(nREs), y = nvars, fill = bg)) +
  geom_col(width=0.9) +
  geom_text(aes(label=nvars), vjust=-0.5, color="black", size=4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_fill_manual(values=bg_color()) +
  labs(title = "",
       x = "Number of response elements bound", 
       y = "",
       fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.position = c(0.9, 0.9),
        strip.background = element_blank(),
        strip.text.y = element_blank())

a1 + a2 + plot_layout(widths = c(1, 5))

# plot as proportion promiscuous vs. specific
totals <- multiple_REs_variants %>%
  mutate(specific = factor(ifelse(nREs == 1, "specific", "promiscuous"),
                           levels = c("specific", "promiscuous"))) %>%
  group_by(bg, specific) %>%
  count(name = "nvars") %>%
  group_by(bg) %>%
  summarize(total = sum(nvars))
a3 <- multiple_REs_variants %>%
  mutate(specific = factor(ifelse(nREs == 1, "specific", "promiscuous"),
                           levels = c("specific", "promiscuous"))) %>%
  group_by(bg, specific) %>%
  count(name = "nvars") %>%
  ggplot(aes(x = bg, y = nvars, fill = bg, alpha = fct_rev(specific))) +
  geom_bar(stat = "identity", width=0.9, position = "fill") +
  geom_text(aes(label=nvars), position = position_fill(vjust = 0.5),
            color="black", size=4, alpha = 1) +
  # geom_text(data = totals, 
  #           aes(x = bg, label = total, y = 1, fill = NULL, alpha = NULL), 
  #           vjust = -0.5, size = 4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values=bg_color()) +
  scale_alpha_manual(values = c(0.5, 1)) +
  labs(title = "", x = "Ancestral\nbackground", 
       y = "Proportion of protein variants",
       fill = "Ancestral\nbackground",
       alpha = "Specificity") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.position = "none",
        strip.background = element_blank(),
        strip.text.y = element_blank()) +
  guides(x = guide_axis(angle = 45))

# plot as proportion promiscuous
a4 <- multiple_REs_variants %>%
  mutate(specific = factor(ifelse(nREs == 1, "specific", "promiscuous"),
                           levels = c("specific", "promiscuous"))) %>%
  group_by(bg) %>%
  summarize(prop = sum(specific == "promiscuous") / n()) %>%
  ggplot(aes(x = bg, y = prop, fill = bg)) +
  geom_col(width=0.9) +
  scale_fill_manual(values=bg_color()) +
  labs(title = "", x = "Ancestral\nbackground", 
       y = "Fraction of promiscuous protein variants",
       fill = "Ancestral\nbackground",
       alpha = "Specificity") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.position = "none",
        strip.background = element_blank(),
        strip.text.y = element_blank()) +
  guides(x = guide_axis(angle = 45))


# plot which REs each RH variant is active on by number of genotypes that it 
# binds to

# Find the RE variant(s) that is (are) bound by each protein variant. If a
# a protein variant binds to multiple sets of REs significantly but the union
# of those REs are not significantly bound, take the set with the highest
# p-value
multiple_REs_bound_data <- lapply(multiple_REs_bound_data, function(x)
  x %>% group_by(bg, AA_var) %>% arrange(desc(padj), .by_group = TRUE))
multiple_REs_variants$RE <- NA
for(i in 1:nrow(multiple_REs_variants)) {
  row <- multiple_REs_variants[i,]
  revars <- multiple_REs_bound_data[[as.numeric(row[3])]] %>% 
    ungroup() %>%
    semi_join(row, by = c("AA_var", "bg")) %>%
    slice(1) %>% 
    select(2:(as.numeric(row[3])+1)) %>% 
    t() %>% 
    str_c(collapse = ", ")
  multiple_REs_variants[i, "RE"] <- revars
}

# plot
b <- multiple_REs_variants %>%
  group_by(bg, nREs) %>%
  count(RE) %>%
  arrange(n) %>%
  ggplot(aes(x = factor(nREs), y = n, color = RE, fill = bg, label = RE)) +
  geom_col(width = 0.9, color = "black", position = "fill") +
  facet_grid(rows = vars(bg)) +
  geom_text(aes(color = bg), 
            position = position_fill(vjust = 0.5), size = 2.5) +
  geom_text(data = multiple_REs_variants %>% 
              group_by(bg, nREs) %>% count(name = "nvars"),
            aes(x = factor(nREs), label=nvars), y = 1, vjust=-0.5, color="black", size=4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values=bg_color()) +
  scale_color_manual(values = c("white", "black"), guide = "none") +
  labs(title = "",
       x = "Number of REs bound", 
       y = "Fraction of protein variants binding\neach RE combination",
       fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.position = c(0.9, 0.9),
        strip.background = element_blank(),
        strip.text.y = element_blank())
b


# for each RE, how many protein variants bind it specifically vs. promiscuously?
RE_frac_specific <- data.frame(bg = rep(NA, 32), RE = NA, 
                               specific = NA, promiscuous = NA)
i <- 1
for(revar in REs[[1]]) {
  for(background in c("AncSR1", "AncSR2")) {
    specific <- multiple_REs_variants %>%
      filter(bg == background, nREs == 1, RE == revar) %>%
      nrow()
    promiscuous <- multiple_REs_variants %>%
      filter(bg == background, nREs > 1, 
             grepl(sub("\\(..\\)", "", revar), RE)) %>%
      nrow()
    RE_frac_specific[i,] <- c(background, revar, specific, promiscuous)
    i <- i + 1
  }
}

c <- RE_frac_specific %>%
  pivot_longer(3:4, names_to = "specific", values_to = "n") %>%
  ggplot(aes(x = factor(RE, levels = levels(REs[[1]])), 
             y = as.numeric(n), 
             fill = bg, 
             alpha = factor(specific, levels = c("specific", "promiscuous")))) +
  geom_col(width = 0.9, position = "dodge") +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_alpha_manual(values = c(1, 0.5)) +
  labs(x = "Response element", y = "Number of protein variants",
       fill = "Ancestral\nbackground", alpha = "Specificity") +
  scale_fill_manual(values=bg_color()) +
  theme_classic() +
  guides(x = guide_axis(angle = 45)) +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        strip.background = element_blank(),
        strip.text.y = element_blank())
c

# plot as proportion promiscuous vs. specific
totals <- RE_frac_specific %>%
  pivot_longer(3:4, names_to = "specific", values_to = "n") %>%
  mutate(n = as.numeric(n)) %>%
  group_by(bg, RE) %>%
  summarize(total = sum(n))
c2 <- RE_frac_specific %>%
  pivot_longer(3:4, names_to = "specific", values_to = "n") %>%
  mutate(n = as.numeric(n)) %>%
  ggplot(aes(x = factor(RE, levels = levels(REs[[1]])), 
             y = n, 
             fill = bg, 
             alpha = factor(specific, levels = c("promiscuous", "specific")))) +
  geom_bar(stat = "identity", width = 0.9, position = "fill") +
  # scale_y_continuous(expand = c(0, 0.1)) +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_alpha_manual(values = c(0.5, 1)) +
  # geom_text(data = totals, 
  #           aes(x = RE, label = total, y = 1, fill = NULL, alpha = NULL), 
  #           vjust = -0.5) +
  labs(x = "Response element", y = "",
       fill = "Ancestral\nbackground", alpha = "Specificity") +
  scale_fill_manual(values=bg_color()) +
  theme_classic() +
  guides(x = guide_axis(angle = 45)) +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        strip.background = element_blank(),
        strip.text.y = element_blank())

# plot as proportion promiscuous
c3 <- RE_frac_specific %>%
  mutate(specific = as.numeric(specific),
         promiscuous = as.numeric(promiscuous),
         prop = promiscuous / (specific + promiscuous)) %>%
  ggplot(aes(x = factor(RE, levels = levels(REs[[1]])), y = prop, fill = bg)) +
  geom_col(width=0.9, position = "dodge") +
  scale_fill_manual(values=bg_color()) +
  labs(title = "", x = "Ancestral\nbackground", 
       y = "Fraction of promiscuous protein variants",
       fill = "Ancestral\nbackground",
       alpha = "Specificity") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.position = "none",
        strip.background = element_blank(),
        strip.text.y = element_blank()) +
  guides(x = guide_axis(angle = 45))

a3 + plot_spacer() + c2 + plot_layout(widths = c(1.5, 0.5, 6))

# plot as number promiscuous vs. specific
c4 <- RE_frac_specific %>%
  pivot_longer(3:4, names_to = "specific", values_to = "n") %>%
  mutate(n = as.numeric(n)) %>%
  ggplot(aes(x = factor(RE, levels = levels(REs[[1]])), 
             y = n, 
             fill = bg, 
             alpha = factor(specific, levels = c("promiscuous", "specific")))) +
  geom_bar(stat = "identity", width = 0.9, position = "stack") +
  # scale_y_continuous(expand = c(0, 0.1)) +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_alpha_manual(values = c(0.5, 1)) +
  # geom_text(data = totals, 
  #           aes(x = RE, label = total, y = 1, fill = NULL, alpha = NULL), 
  #           vjust = -0.5) +
  labs(x = "Response element", y = "Number of functional protein variants",
       fill = "Ancestral\nbackground", alpha = "Specificity") +
  scale_fill_manual(values=bg_color()) +
  theme_classic() +
  guides(x = guide_axis(angle = 45)) +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        strip.background = element_blank(),
        strip.text.y = element_blank())
c4

# plot as number promiscuous vs. specific side by side
c5 <- RE_frac_specific %>%
  pivot_longer(3:4, names_to = "specific", values_to = "n") %>%
  mutate(n = as.numeric(n)) %>%
  ggplot(aes(x = bg, 
             y = n, 
             fill = bg, 
             alpha = factor(specific, levels = c("promiscuous", "specific")))) +
  geom_bar(stat = "identity", width = 0.9, position = "stack") +
  facet_grid(cols = vars(factor(RE, levels = levels(REs[[1]])))) +
  # scale_y_continuous(expand = c(0, 0.1)) +
  scale_alpha_manual(values = c(0.5, 1)) +
  # geom_text(data = totals, 
  #           aes(x = RE, label = total, y = 1, fill = NULL, alpha = NULL), 
  #           vjust = -0.5) +
  labs(x = "Response element", y = "Number of functional protein variants",
       fill = "Ancestral\nbackground", alpha = "Specificity") +
  scale_fill_manual(values=bg_color()) +
  theme_classic() +
  guides(x = guide_axis(angle = 45)) +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        strip.background = element_blank(),
        strip.text.x = element_blank())
c5
```


## What is the distribution of fluorescence for protein variants that bind specifically vs. promiscously?

```{r, purl = FALSE, eval = F}
meanF_data_functional <- meanF_data_functional %>%
  left_join(multiple_REs_variants %>% select(-RE)) %>%
  mutate(nREs = ifelse(nREs == 1, "specific", "promiscuous")) %>% 
  rename(specific = nREs)
a <- meanF_data_functional %>%
  drop_na(specific) %>%
  mutate(specific = factor(specific, levels = c("specific", "promiscuous"))) %>%
  ggplot(aes(x = specific, 
             y = avg_meanF, fill = bg, alpha = specific)) +
  geom_boxplot() +
  scale_alpha_manual(values = c(1, 0.5), guide = "none") +
  labs(y = "Fluorescence", fill = "Ancestral\nbackground", x = "") +
  scale_fill_manual(values=bg_color()) +
  geom_signif(aes(group = specific),
              comparisons = list(c("specific", "promiscuous")), 
              test = "wilcox.test",
              map_signif_level = TRUE) +
  facet_grid(cols = vars(bg)) +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        strip.background = element_blank(),
        strip.text.x = element_blank())
a
```


```{r, purl = FALSE, eval = F}
a2 <- multiple_REs_variants %>%
  group_by(bg, nREs) %>% 
  count(name = "nvars") %>%
  ggplot(aes(x = as.factor(nREs), y = nvars, fill = bg)) +
  geom_col(width=0.9) +
  geom_text(aes(label=nvars), vjust=-0.5, color="black", size=4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  facet_grid(rows = vars(bg), scales = "free") +
  scale_fill_manual(values=bg_color()) +
  labs(title = "",
       x = "Number of response elements bound", 
       y = "Number of protein variants",
       fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.position = c(0.9, 0.9),
        strip.background = element_blank(),
        strip.text.y = element_blank())
a2

c <- fluorescence_both_backgrounds %>%
  pivot_longer(3:4, names_to = "background") %>%
  ggplot(aes(x = background, y = value, fill = background)) +
  geom_boxplot() +
  scale_fill_manual(values = c(bg_color()), drop = FALSE) +
  labs(title = "Protein:RE variant combos\nfunctional in both backgrounds", 
       x = "Ancestral background", y = "Fluorescence", 
       fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        axis.line.x = element_line(color = "black",),
        legend.position = "none",
        plot.caption = element_text(hjust = 0)) +
  guides(x = guide_axis(angle = 45)) +
  geom_signif(comparisons = list(c("AncSR1", "AncSR2")), 
              test = "wilcox.test",
              test.args = list(alternative = "less"),
              map_signif_level = function(p) sprintf("p = %.2g", p))
c

c + a2 + plot_layout(widths = c(1.5, 3))
```


## What is the genetic basis of specificity vs. promiscuity?

```{r, purl = FALSE, eval = F}
# logo plots for all functional variants in the AncSR2 background
a <- ggseqlogo(meanF_data_functional %>% 
                 filter(bg == "AncSR2") %>%
                 pull(AA_var) %>% unique() %>% as.character(),
                 method = "bits") +
  theme(text=element_text(size=fontsize),
        plot.title = element_text(size = fontsize),
        legend.position = "none") +
  labs(x="AA position", title="All AncSR2 protein variants")
a

# logo plots for variants that bind specifically to one RE in the AncSR2 background
AncSR2_specific_vars <- lapply(REs[[1]], function(x) multiple_REs_variants %>%
                                 filter(bg == "AncSR2", nREs == 1, RE == x) %>% 
                                 pull(AA_var) %>%
                                 as.character())
names(AncSR2_specific_vars) <- REs[[1]]
AncSR2_specific_vars <- AncSR2_specific_vars[sapply(AncSR2_specific_vars, length) >= 50]
b <- ggseqlogo(AncSR2_specific_vars, 
          method="bits", ncol = length(meanF_data_functional)) +
  theme(text=element_text(size=fontsize),
        strip.text.x = element_text(size = fontsize),
        legend.position = "none") +
  labs(x="AA position")
b


# logo plots for variants that bind promiscuously to more than one RE in the AncSR2 background
c <- ggseqlogo(meanF_data_functional %>% 
                 filter(specific == "promiscuous", bg == "AncSR2") %>%
                 pull(AA_var) %>% unique() %>% as.character(), 
          method="bits") +
  theme(text=element_text(size=fontsize),
        legend.position = "none") +
  labs(x="AA position", title="Promiscuous AncSR2 protein variants")
c
```


## do variants switch between functional/nonfunctional/promiscuous/specific between AncSR1 and AnSR2?

```{r, purl = FALSE, eval = F}
alluvial_data <- multiple_REs_variants %>%
  mutate(specificity = factor(ifelse(nREs > 1, "promiscuous", RE), 
                           levels = c(levels(REs[[1]]), 
                                      "same specificity", "switched specificity", 
                                      "promiscuous", "nonfunctional"))) %>%
  select(AA_var, bg, specificity) %>%
  pivot_wider(names_from = bg, values_from = specificity) %>%
  replace_na(list(AncSR1 = "nonfunctional", AncSR2 = "nonfunctional")) %>%
  filter(AncSR1 != "nonfunctional")
for(i in 1:nrow(alluvial_data)) {
  spec1 <- as.character(alluvial_data[i,2] %>% pull(1))
  spec2 <- as.character(alluvial_data[i,3] %>% pull(1))
  if(spec2 %in% as.character(REs[[1]])) {
    if(spec1 %in% as.character(REs[[1]])) {
      if(spec1 == spec2) alluvial_data[i,3] <- "same specificity"
      else alluvial_data[i,3] <- "switched specificity"
    } else {
      alluvial_data[i,3] <- "switched specificity"
    }
  }
}

alluvial_data <- alluvial_data %>%
  mutate(AncSR1 = factor(ifelse(AncSR1 %in% REs[[1]], "specific", "promiscuous"),
                         levels = c("promiscuous", "specific")),
         AncSR2 = factor(AncSR2, levels = c("promiscuous", "same specificity", 
                                            "switched specificity", "nonfunctional")))


a <- alluvial_data %>%
  filter(AncSR2 != "nonfunctional") %>%
  count(AncSR1, AncSR2) %>%
  ggplot(aes(axis1 = AncSR1, 
             axis2 = AncSR2, 
             y = n)) +
  geom_alluvium(aes(fill = AncSR2), width = 3/5) +
  geom_stratum(width = 3/5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 4) +
  scale_x_discrete(limits = c("AncSR1\nbackground", "AncSR2\nbackground"),
                   expand = c(0.15, 0.05),
                   position = "top") +
  # scale_fill_manual(values = viridis(4)) +
  labs(title = "Protein variants functional\nin both backgrounds", 
       x = "", y = "Number of protein variants",
       fill = "AncSR2 phenotype") +
  theme_classic() +
  guides(fill = "none") +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text.x = element_text(size = fontsize))
a


# mean fluorescence for things that became promiscuous, 
# retained specificity, or retained promiscuity
b <- alluvial_data %>%
  filter(AncSR2 %in% c("promiscuous", "same specificity")) %>%
  unite(col = "phechange", AncSR1, AncSR2, sep = " to ") %>%
  mutate(phechange = factor(ifelse(phechange == "specific to same specificity",
                            "retained specificity", 
                            ifelse(phechange == "promiscuous to promiscuous",
                                   "retained promiscuity",
                                   phechange)),
                            levels = c("retained specificity",
                                       "specific to promiscuous",
                                   "retained promiscuity" ))) %>%
  inner_join(meanF_data_functional) %>%
  filter(bg == "AncSR1") %>%
  ggplot(aes(x = phechange, y = avg_meanF, fill = bg)) +
  geom_boxplot() +
  scale_fill_manual(values = bg_color("AncSR1")) +
  labs(x = "AncSR1 to AncSR2\nphenotype change", y = "Fluorescence", 
       fill = "", title = "Protein:RE variant combos\nfunctional in AncSR1 background") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        axis.line.x = element_line(color = "black",),
        legend.position = "none",
        plot.caption = element_text(hjust = 0)) +
  guides(x = guide_axis(angle = 45)) +
  geom_signif(comparisons = list(c("retained specificity", "specific to promiscuous"),
                                 c("specific to promiscuous", "retained promiscuity")), 
              test = "wilcox.test",
              test.args = list(alternative = "less"),
              map_signif_level = function(p) sprintf("p = %.2g", p))

c <- fluorescence_both_backgrounds %>%
  pivot_longer(3:4, names_to = "background") %>%
  ggplot(aes(x = background, y = value, fill = background)) +
  geom_boxplot() +
  scale_fill_manual(values = c(bg_color()), drop = FALSE) +
  labs(title = "Protein:RE variant combos\nfunctional in both backgrounds", 
       x = "Ancestral background", y = "", fill = "Ancestral\nbackground") +
  theme_classic() +
  theme(text = element_text(size = fontsize),
        plot.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        axis.line.x = element_line(color = "black",),
        legend.position = "right",
        plot.caption = element_text(hjust = 0)) +
  guides(x = guide_axis(angle = 45)) +
  geom_signif(comparisons = list(c("AncSR1", "AncSR2")), 
              test = "wilcox.test",
              test.args = list(alternative = "less"),
              map_signif_level = function(p) sprintf("p = %.2g", p))

b + c + plot_layout(widths = c(3, 3))
```



# Network analysis

Let's create the genotype networks, where each node is a protein variant and their associated traits are the REs that they bind to.

```{r, purl = FALSE, eval = F}
# create data frame of which protein variants bind to which REs
# REs_bound <- multiple_REs_variants %>%
#   separate_longer_delim(cols = RE, delim = ", ") %>%
#   mutate(present = 1) %>%
#   pivot_wider(names_from = RE, values_from = present)
  

## AncSR1
AncSR1_comb <- combn(meanF_data_specificity %>% 
                       filter(bg == "AncSR1", nfxnal > 0) %>% 
                       pull(AA_var) %>% 
                       as.character(), 2)
AncSR1_edges <- t(AncSR1_comb)
AncSR1_connected <- apply(AncSR1_edges, 1, connected)
AncSR1_connected <- AncSR1_edges[AncSR1_connected,]
  

# create undirected graph where edges represent single step mutations between
# RH genotypes permissible by the genetic code; node attributes are boolean
# variables indicating binding to each RE, and one integer variable for number
# of REs bound
AncSR1_graph <- graph_from_data_frame(AncSR1_connected, directed=FALSE, 
                                      vertices = meanF_data_specificity %>% 
                                        filter(bg == "AncSR1", nfxnal > 0) %>% 
                                        select(AA_var, `functional_ERE (GT)`:nfxnal) %>%
                                        mutate(AA_var = as.character(AA_var)))
write_graph(AncSR1_graph, 
            file.path(results_dir, "AncSR1_RH_network.graphml"),
            format="graphml")

## AncSR2
AncSR2_comb <- combn(meanF_data_specificity %>% 
                       filter(bg == "AncSR2", nfxnal > 0) %>% 
                       pull(AA_var) %>% 
                       as.character(), 2)
AncSR2_edges <- t(AncSR2_comb)
AncSR2_connected <- apply(AncSR2_edges, 1, connected)
AncSR2_connected <- AncSR2_edges[AncSR2_connected,]
  

# create undirected graph where edges represent single step mutations between
# RH genotypes permissible by the genetic code; node attributes are boolean
# variables indicating binding to each RE, and one integer variable for number
# of REs bound
AncSR2_graph <- graph_from_data_frame(AncSR2_connected, directed=FALSE, 
                                      vertices = meanF_data_specificity %>% 
                                        filter(bg == "AncSR2", nfxnal > 0) %>% 
                                        select(AA_var, `functional_ERE (GT)`:nfxnal) %>%
                                        mutate(AA_var = as.character(AA_var)))
write_graph(AncSR2_graph, 
            file.path(results_dir, "AncSR2_RH_network.graphml"),
            format="graphml")
```


RH-RE networks

```{r, purl = FALSE, eval = F}
# AncSR1
AncSR1_RHRE_comb <- combn(meanF_data_specificity %>% 
                            filter(bg == "AncSR1", nfxnal > 0) %>% 
                            select(bg, AA_var, 
                                   `functional_ERE (GT)`:functional_TT) %>%
                            pivot_longer(`functional_ERE (GT)`:functional_TT, 
                                         names_to = "RE", 
                                         names_prefix = "functional_", 
                                         values_to = "functional") %>%
                            filter(functional) %>%
                            mutate(RE = sub(".+ \\(", "", RE)) %>%
                            mutate(RE = sub("\\)", "", RE)) %>%
                            unite(AA_var, RE, col = "var", sep = "") %>%
                            pull(var), 2)
AncSR1_RHRE_edges <- t(AncSR1_RHRE_comb)
AncSR1_RHRE_connected <- apply(AncSR1_RHRE_edges, 1, connected_RH_RE)
AncSR1_RHRE_connected <- AncSR1_RHRE_edges[AncSR1_RHRE_connected,]
AncSR1_RHRE_vertices <- unique(as.character(AncSR1_RHRE_comb))
AncSR1_RHRE_vertices <- data.frame(var = AncSR1_RHRE_vertices,
                                   RE = sub("....", "", AncSR1_RHRE_vertices))

AncSR1_RHRE_graph <- graph_from_data_frame(AncSR1_RHRE_connected, directed=FALSE, 
                                           vertices = AncSR1_RHRE_vertices)
write_graph(AncSR1_RHRE_graph, 
            file.path(results_dir, "AncSR1_RHRE_network.graphml"),
            format="graphml")
```

```{r, purl = FALSE, eval = F}
# AncSR2
AncSR2_RHRE_comb <- combn(meanF_data_specificity %>% 
                            filter(bg == "AncSR2", nfxnal > 0) %>% 
                            select(bg, AA_var, 
                                   `functional_ERE (GT)`:functional_TT) %>%
                            pivot_longer(`functional_ERE (GT)`:functional_TT, 
                                         names_to = "RE", 
                                         names_prefix = "functional_", 
                                         values_to = "functional") %>%
                            filter(functional) %>%
                            mutate(RE = sub(".+ \\(", "", RE)) %>%
                            mutate(RE = sub("\\)", "", RE)) %>%
                            unite(AA_var, RE, col = "var", sep = "") %>%
                            pull(var), 2)
AncSR2_RHRE_edges <- t(AncSR2_RHRE_comb)
if(!file.exists(file.path(results_dir, "AncSR2_RHRE_connected.rda"))) {
  AncSR2_RHRE_connected <- apply(AncSR2_RHRE_edges, 1, connected_RH_RE)
  save(AncSR2_RHRE_connected, file = file.path(results_dir, "AncSR2_RHRE_connected.rda"))
} else load(file.path(results_dir, "AncSR2_RHRE_connected.rda"))
AncSR2_RHRE_connected <- AncSR2_RHRE_edges[AncSR2_RHRE_connected,]
AncSR2_RHRE_vertices <- unique(as.character(AncSR2_RHRE_comb))
AncSR2_RHRE_vertices <- data.frame(var = AncSR2_RHRE_vertices,
                                   RE = sub("....", "", AncSR2_RHRE_vertices))

AncSR2_RHRE_graph <- graph_from_data_frame(AncSR2_RHRE_connected, directed=FALSE, 
                                           vertices = AncSR2_RHRE_vertices)
write_graph(AncSR2_RHRE_graph, 
            file.path(results_dir, "AncSR2_RHRE_network.graphml"),
            format="graphml")
```

